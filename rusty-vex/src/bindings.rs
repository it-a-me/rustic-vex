/* automatically generated by rust-bindgen 0.61.0 */

pub const PROS_VERSION_MAJOR: u32 = 3;
pub const PROS_VERSION_MINOR: u32 = 7;
pub const PROS_VERSION_PATCH: u32 = 2;
pub const PROS_VERSION_STRING: &[u8; 6usize] = b"3.7.2\0";
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const PROS_ERR: u32 = 2147483647;
pub const INTERNAL_ADI_PORT: u32 = 22;
pub const NUM_ADI_PORTS: u32 = 8;
pub const HIGH: u32 = 1;
pub const LOW: u32 = 0;
pub const INPUT: u32 = 0;
pub const OUTPUT: u32 = 1;
pub const INPUT_ANALOG: u32 = 2;
pub const OUTPUT_ANALOG: u32 = 3;
pub const COLOR_ALICE_BLUE: u32 = 15792383;
pub const COLOR_ANTIQUE_WHITE: u32 = 16444375;
pub const COLOR_AQUA: u32 = 65535;
pub const COLOR_AQUAMARINE: u32 = 8388564;
pub const COLOR_AZURE: u32 = 15794175;
pub const COLOR_BEIGE: u32 = 16119260;
pub const COLOR_BISQUE: u32 = 16770244;
pub const COLOR_BLACK: u32 = 0;
pub const COLOR_BLANCHED_ALMOND: u32 = 16772045;
pub const COLOR_BLUE: u32 = 255;
pub const COLOR_BLUE_VIOLET: u32 = 9055202;
pub const COLOR_BROWN: u32 = 10824234;
pub const COLOR_BURLY_WOOD: u32 = 14596231;
pub const COLOR_CADET_BLUE: u32 = 6266528;
pub const COLOR_CHARTREUSE: u32 = 8388352;
pub const COLOR_CHOCOLATE: u32 = 13789470;
pub const COLOR_CORAL: u32 = 16744272;
pub const COLOR_CORNFLOWER_BLUE: u32 = 6591981;
pub const COLOR_CORNSILK: u32 = 16775388;
pub const COLOR_CRIMSON: u32 = 14423100;
pub const COLOR_CYAN: u32 = 65535;
pub const COLOR_DARK_BLUE: u32 = 139;
pub const COLOR_DARK_CYAN: u32 = 35723;
pub const COLOR_DARK_GOLDENROD: u32 = 12092939;
pub const COLOR_DARK_GRAY: u32 = 11119017;
pub const COLOR_DARK_GREEN: u32 = 25600;
pub const COLOR_DARK_KHAKI: u32 = 12433259;
pub const COLOR_DARK_MAGENTA: u32 = 9109643;
pub const COLOR_DARK_OLIVE_GREEN: u32 = 5597999;
pub const COLOR_DARK_ORANGE: u32 = 16747520;
pub const COLOR_DARK_ORCHID: u32 = 10040012;
pub const COLOR_DARK_RED: u32 = 9109504;
pub const COLOR_DARK_SALMON: u32 = 15308410;
pub const COLOR_DARK_SEA_GREEN: u32 = 9419919;
pub const COLOR_DARK_SLATE_GRAY: u32 = 3100495;
pub const COLOR_DARK_TURQUOISE: u32 = 52945;
pub const COLOR_DARK_VIOLET: u32 = 9699539;
pub const COLOR_DEEP_PINK: u32 = 16716947;
pub const COLOR_DEEP_SKY_BLUE: u32 = 49151;
pub const COLOR_DIM_GRAY: u32 = 6908265;
pub const COLOR_DODGER_BLUE: u32 = 2003199;
pub const COLOR_FIRE_BRICK: u32 = 11674146;
pub const COLOR_FLORAL_WHITE: u32 = 16775920;
pub const COLOR_FOREST_GREEN: u32 = 2263842;
pub const COLOR_FUCHSIA: u32 = 16711935;
pub const COLOR_GAINSBORO: u32 = 14474460;
pub const COLOR_GHOST_WHITE: u32 = 16316671;
pub const COLOR_GOLD: u32 = 16766720;
pub const COLOR_GOLDENROD: u32 = 14329120;
pub const COLOR_GRAY: u32 = 8421504;
pub const COLOR_GREEN: u32 = 32768;
pub const COLOR_GREEN_YELLOW: u32 = 11403055;
pub const COLOR_HONEYDEW: u32 = 15794160;
pub const COLOR_HOT_PINK: u32 = 16738740;
pub const COLOR_INDIAN_RED: u32 = 13458524;
pub const COLOR_INDIGO: u32 = 4915330;
pub const COLOR_IVORY: u32 = 16777200;
pub const COLOR_KHAKI: u32 = 15787660;
pub const COLOR_LAVENDER: u32 = 15132410;
pub const COLOR_LAVENDER_BLUSH: u32 = 16773365;
pub const COLOR_LAWN_GREEN: u32 = 8190976;
pub const COLOR_LEMON_CHIFFON: u32 = 16775885;
pub const COLOR_LIGHT_BLUE: u32 = 11393254;
pub const COLOR_LIGHT_CORAL: u32 = 15761536;
pub const COLOR_LIGHT_CYAN: u32 = 14745599;
pub const COLOR_LIGHT_GOLDENROD_YELLOW: u32 = 16448210;
pub const COLOR_LIGHT_GREEN: u32 = 9498256;
pub const COLOR_LIGHT_GRAY: u32 = 13882323;
pub const COLOR_LIGHT_PINK: u32 = 16758465;
pub const COLOR_LIGHT_SALMON: u32 = 16752762;
pub const COLOR_LIGHT_SEA_GREEN: u32 = 2142890;
pub const COLOR_LIGHT_SKY_BLUE: u32 = 8900346;
pub const COLOR_LIGHT_SLATE_GRAY: u32 = 7833753;
pub const COLOR_LIGHT_STEEL_BLUE: u32 = 11584734;
pub const COLOR_LIGHT_YELLOW: u32 = 16777184;
pub const COLOR_LIME: u32 = 65280;
pub const COLOR_LIME_GREEN: u32 = 3329330;
pub const COLOR_LINEN: u32 = 16445670;
pub const COLOR_MAGENTA: u32 = 16711935;
pub const COLOR_MAROON: u32 = 8388608;
pub const COLOR_MEDIUM_AQUAMARINE: u32 = 6737322;
pub const COLOR_MEDIUM_BLUE: u32 = 205;
pub const COLOR_MEDIUM_ORCHID: u32 = 12211667;
pub const COLOR_MEDIUM_PURPLE: u32 = 9662683;
pub const COLOR_MEDIUM_SEA_GREEN: u32 = 3978097;
pub const COLOR_MEDIUM_SLATE_BLUE: u32 = 8087790;
pub const COLOR_MEDIUM_SPRING_GREEN: u32 = 64154;
pub const COLOR_MEDIUM_TURQUOISE: u32 = 4772300;
pub const COLOR_MEDIUM_VIOLET_RED: u32 = 13047173;
pub const COLOR_MIDNIGHT_BLUE: u32 = 1644912;
pub const COLOR_MINT_CREAM: u32 = 16121850;
pub const COLOR_MISTY_ROSE: u32 = 16770273;
pub const COLOR_MOCCASIN: u32 = 16770229;
pub const COLOR_NAVAJO_WHITE: u32 = 16768685;
pub const COLOR_NAVY: u32 = 128;
pub const COLOR_OLD_LACE: u32 = 16643558;
pub const COLOR_OLIVE: u32 = 8421376;
pub const COLOR_OLIVE_DRAB: u32 = 7048739;
pub const COLOR_ORANGE: u32 = 16753920;
pub const COLOR_ORANGE_RED: u32 = 16729344;
pub const COLOR_ORCHID: u32 = 14315734;
pub const COLOR_PALE_GOLDENROD: u32 = 15657130;
pub const COLOR_PALE_GREEN: u32 = 10025880;
pub const COLOR_PALE_TURQUOISE: u32 = 11529966;
pub const COLOR_PALE_VIOLET_RED: u32 = 14381203;
pub const COLOR_PAPAY_WHIP: u32 = 16773077;
pub const COLOR_PEACH_PUFF: u32 = 16767673;
pub const COLOR_PERU: u32 = 13468991;
pub const COLOR_PINK: u32 = 16761035;
pub const COLOR_PLUM: u32 = 14524637;
pub const COLOR_POWDER_BLUE: u32 = 11591910;
pub const COLOR_PURPLE: u32 = 8388736;
pub const COLOR_RED: u32 = 16711680;
pub const COLOR_ROSY_BROWN: u32 = 12357519;
pub const COLOR_ROYAL_BLUE: u32 = 4286945;
pub const COLOR_SADDLE_BROWN: u32 = 9127187;
pub const COLOR_SALMON: u32 = 16416882;
pub const COLOR_SANDY_BROWN: u32 = 16032864;
pub const COLOR_SEA_GREEN: u32 = 3050327;
pub const COLOR_SEASHELL: u32 = 16774638;
pub const COLOR_SIENNA: u32 = 10506797;
pub const COLOR_SILVER: u32 = 12632256;
pub const COLOR_SKY_BLUE: u32 = 8900331;
pub const COLOR_SLATE_BLUE: u32 = 6970061;
pub const COLOR_SLATE_GRAY: u32 = 7372944;
pub const COLOR_SNOW: u32 = 16775930;
pub const COLOR_SPRING_GREEN: u32 = 65407;
pub const COLOR_STEEL_BLUE: u32 = 4620980;
pub const COLOR_TAN: u32 = 13808780;
pub const COLOR_TEAL: u32 = 32896;
pub const COLOR_THISTLE: u32 = 14204888;
pub const COLOR_TOMATO: u32 = 16737095;
pub const COLOR_TURQUOISE: u32 = 4251856;
pub const COLOR_VIOLET: u32 = 15631086;
pub const COLOR_WHEAT: u32 = 16113331;
pub const COLOR_WHITE: u32 = 16777215;
pub const COLOR_WHITE_SMOKE: u32 = 16119285;
pub const COLOR_YELLOW: u32 = 16776960;
pub const COLOR_YELLOW_GREEN: u32 = 10145074;
pub const COLOR_DARK_GREY: u32 = 11119017;
pub const COLOR_DARK_SLATE_GREY: u32 = 3100495;
pub const COLOR_DIM_GREY: u32 = 6908265;
pub const COLOR_GREY: u32 = 8421504;
pub const COLOR_LIGHT_GREY: u32 = 13882323;
pub const COLOR_LIGHT_SLATE_GREY: u32 = 7833753;
pub const COLOR_SLATE_GREY: u32 = 7372944;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const PROS_ERR_BYTE: u32 = 127;
pub const PROS_ERR_2_BYTE: u32 = 32767;
pub const PROS_SUCCESS: u32 = 1;
pub const IMU_MINIMUM_DATA_RATE: u32 = 5;
pub const LINK_BUFFER_SIZE: u32 = 512;
pub const NUM_V5_PORTS: u32 = 22;
pub const COMPETITION_DISABLED: u32 = 1;
pub const COMPETITION_AUTONOMOUS: u32 = 2;
pub const COMPETITION_CONNECTED: u32 = 4;
pub const OPT_GESTURE_ERR: u32 = 127;
pub const OPT_COUNT_ERR: u32 = 32767;
pub const OPT_TIME_ERR: u32 = 2147483647;
pub const TASK_PRIORITY_MAX: u32 = 16;
pub const TASK_PRIORITY_MIN: u32 = 1;
pub const TASK_PRIORITY_DEFAULT: u32 = 8;
pub const TASK_STACK_DEPTH_DEFAULT: u32 = 8192;
pub const TASK_STACK_DEPTH_MIN: u32 = 512;
pub const TASK_NAME_MAX_LEN: u32 = 32;
pub const ROTATION_MINIMUM_DATA_RATE: u32 = 5;
pub const VISION_OBJECT_ERR_SIG: u32 = 255;
pub const VISION_FOV_WIDTH: u32 = 316;
pub const VISION_FOV_HEIGHT: u32 = 212;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const adi_port_config_e_E_ADI_ANALOG_IN: adi_port_config_e = 0;
pub const adi_port_config_e_E_ADI_ANALOG_OUT: adi_port_config_e = 1;
pub const adi_port_config_e_E_ADI_DIGITAL_IN: adi_port_config_e = 2;
pub const adi_port_config_e_E_ADI_DIGITAL_OUT: adi_port_config_e = 3;
pub const adi_port_config_e_E_ADI_SMART_BUTTON: adi_port_config_e = 2;
pub const adi_port_config_e_E_ADI_SMART_POT: adi_port_config_e = 0;
pub const adi_port_config_e_E_ADI_LEGACY_BUTTON: adi_port_config_e = 2;
pub const adi_port_config_e_E_ADI_LEGACY_POT: adi_port_config_e = 0;
pub const adi_port_config_e_E_ADI_LEGACY_LINE_SENSOR: adi_port_config_e = 0;
pub const adi_port_config_e_E_ADI_LEGACY_LIGHT_SENSOR: adi_port_config_e = 0;
pub const adi_port_config_e_E_ADI_LEGACY_GYRO: adi_port_config_e = 10;
pub const adi_port_config_e_E_ADI_LEGACY_ACCELEROMETER: adi_port_config_e = 0;
pub const adi_port_config_e_E_ADI_LEGACY_SERVO: adi_port_config_e = 12;
pub const adi_port_config_e_E_ADI_LEGACY_PWM: adi_port_config_e = 13;
pub const adi_port_config_e_E_ADI_LEGACY_ENCODER: adi_port_config_e = 14;
pub const adi_port_config_e_E_ADI_LEGACY_ULTRASONIC: adi_port_config_e = 15;
pub const adi_port_config_e_E_ADI_TYPE_UNDEFINED: adi_port_config_e = 255;
pub const adi_port_config_e_E_ADI_ERR: adi_port_config_e = 2147483647;
#[doc = " Represents the port type for an ADI port."]
pub type adi_port_config_e = ::std::os::raw::c_uint;
#[doc = " Represents the port type for an ADI port."]
pub use self::adi_port_config_e as adi_port_config_e_t;
pub const adi_potentiometer_type_e_E_ADI_POT_EDR: adi_potentiometer_type_e = 0;
pub const adi_potentiometer_type_e_E_ADI_POT_V2: adi_potentiometer_type_e = 1;
#[doc = " Represents the potentiometer version type."]
pub type adi_potentiometer_type_e = ::std::os::raw::c_uint;
#[doc = " Represents the potentiometer version type."]
pub use self::adi_potentiometer_type_e as adi_potentiometer_type_e_t;
extern "C" {
    #[doc = " Gets the configuration for the given ADI port."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port number (from 1-8, 'a'-'h', 'A'-'H') for which to return"]
    #[doc = "        the configuration"]
    #[doc = ""]
    #[doc = " \\return The ADI configuration for the given port"]
    pub fn adi_port_get_config(port: u8) -> adi_port_config_e_t;
}
extern "C" {
    #[doc = " Gets the value for the given ADI port."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port number (from 1-8, 'a'-'h', 'A'-'H') for which the value"]
    #[doc = "        will be returned"]
    #[doc = ""]
    #[doc = " \\return The value stored for the given port"]
    pub fn adi_port_get_value(port: u8) -> i32;
}
extern "C" {
    #[doc = " Configures an ADI port to act as a given sensor type."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port number (from 1-8, 'a'-'h', 'A'-'H') to configure"]
    #[doc = " \\param type"]
    #[doc = "        The configuration type for the port"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn adi_port_set_config(port: u8, type_: adi_port_config_e_t) -> i32;
}
extern "C" {
    #[doc = " Sets the value for the given ADI port."]
    #[doc = ""]
    #[doc = " This only works on ports configured as outputs, and the behavior will change"]
    #[doc = " depending on the configuration of the port."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO  - The given value is not within the range of ADI Ports."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port number (from 1-8, 'a'-'h', 'A'-'H') for which the value"]
    #[doc = "        will be set"]
    #[doc = " \\param value"]
    #[doc = "        The value to set the ADI port to"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn adi_port_set_value(port: u8, value: i32) -> i32;
}
extern "C" {
    #[doc = " Calibrates the analog sensor on the specified port and returns the new"]
    #[doc = " calibration value."]
    #[doc = ""]
    #[doc = " This method assumes that the true sensor value is not actively changing at"]
    #[doc = " this time and computes an average from approximately 500 samples, 1 ms apart,"]
    #[doc = " for a 0.5 s period of calibration. The average value thus calculated is"]
    #[doc = " returned and stored for later calls to the adi_analog_read_calibrated() and"]
    #[doc = " adi_analog_read_calibrated_HR() functions. These functions will return"]
    #[doc = " the difference between this value and the current sensor value when called."]
    #[doc = ""]
    #[doc = " Do not use this function when the sensor value might be unstable"]
    #[doc = " (gyro rotation, accelerometer movement)."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port to calibrate (from 1-8, 'a'-'h', 'A'-'H')"]
    #[doc = ""]
    #[doc = " \\return The average sensor value computed by this function"]
    pub fn adi_analog_calibrate(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the 12-bit value of the specified port."]
    #[doc = ""]
    #[doc = " The value returned is undefined if the analog pin has been switched to a"]
    #[doc = " different mode."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an analog input"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port (from 1-8, 'a'-'h', 'A'-'H') for which the value will be"]
    #[doc = "        returned"]
    #[doc = ""]
    #[doc = " \\return The analog sensor value, where a value of 0 reflects an input voltage"]
    #[doc = " of nearly 0 V and a value of 4095 reflects an input voltage of nearly 5 V"]
    pub fn adi_analog_read(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the 12 bit calibrated value of an analog input port."]
    #[doc = ""]
    #[doc = " The adi_analog_calibrate() function must be run first. This function is"]
    #[doc = " inappropriate for sensor values intended for integration, as round-off error"]
    #[doc = " can accumulate causing drift over time. Use adi_analog_read_calibrated_HR()"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an analog input"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port (from 1-8, 'a'-'h', 'A'-'H') for which the value will be"]
    #[doc = "        returned"]
    #[doc = ""]
    #[doc = " \\return The difference of the sensor value from its calibrated default from"]
    #[doc = " -4095 to 4095"]
    pub fn adi_analog_read_calibrated(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the 16 bit calibrated value of an analog input port."]
    #[doc = ""]
    #[doc = " The adi_analog_calibrate() function must be run first. This is intended for"]
    #[doc = " integrated sensor values such as gyros and accelerometers to reduce drift due"]
    #[doc = " to round-off, and should not be used on a sensor such as a line tracker"]
    #[doc = " or potentiometer."]
    #[doc = ""]
    #[doc = " The value returned actually has 16 bits of \"precision\", even though the ADC"]
    #[doc = " only reads 12 bits, so that error induced by the average value being between"]
    #[doc = " two values when integrated over time is trivial. Think of the value as the"]
    #[doc = " true value times 16."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an analog input"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port (from 1-8, 'a'-'h', 'A'-'H') for which the value will be"]
    #[doc = "        returned"]
    #[doc = ""]
    #[doc = " \\return The difference of the sensor value from its calibrated default from"]
    #[doc = " -16384 to 16384"]
    pub fn adi_analog_read_calibrated_HR(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the digital value (1 or 0) of a port configured as a digital input."]
    #[doc = ""]
    #[doc = " If the port is configured as some other mode, the digital value which"]
    #[doc = " reflects the current state of the port is returned, which may or may not"]
    #[doc = " differ from the currently set value. The return value is undefined for ports"]
    #[doc = " configured as any mode other than a Digital Input."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as a digital input"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port to read (from 1-8, 'a'-'h', 'A'-'H')"]
    #[doc = ""]
    #[doc = " \\return True if the pin is HIGH, or false if it is LOW"]
    pub fn adi_digital_read(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets a rising-edge case for a digital button press."]
    #[doc = ""]
    #[doc = " This function is not thread-safe."]
    #[doc = " Multiple tasks polling a single button may return different results under the"]
    #[doc = " same circumstances, so only one task should call this function for any given"]
    #[doc = " button. E.g., Task A calls this function for buttons 1 and 2. Task B may call"]
    #[doc = " this function for button 3, but should not for buttons 1 or 2. A typical"]
    #[doc = " use-case for this function is to call inside opcontrol to detect new button"]
    #[doc = " presses, and not in any other tasks."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as a digital input"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port to read (from 1-8, 'a'-'h', 'A'-'H')"]
    #[doc = ""]
    #[doc = " \\return 1 if the button is pressed and had not been pressed"]
    #[doc = " the last time this function was called, 0 otherwise."]
    pub fn adi_digital_get_new_press(port: u8) -> i32;
}
extern "C" {
    #[doc = " Sets the digital value (1 or 0) of a port configured as a digital output."]
    #[doc = ""]
    #[doc = " If the port is configured as some other mode, behavior is undefined."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as a digital output"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port to read (from 1-8, 'a'-'h', 'A'-'H')"]
    #[doc = " \\param value"]
    #[doc = "        An expression evaluating to \"true\" or \"false\" to set the output to"]
    #[doc = "        HIGH or LOW respectively, or the constants HIGH or LOW themselves"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn adi_digital_write(port: u8, value: bool) -> i32;
}
extern "C" {
    #[doc = " Configures the port as an input or output with a variety of settings."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port to read (from 1-8, 'a'-'h', 'A'-'H')"]
    #[doc = " \\param mode"]
    #[doc = "        One of INPUT, INPUT_ANALOG, INPUT_FLOATING, OUTPUT, or OUTPUT_OD"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn adi_pin_mode(port: u8, mode: u8) -> i32;
}
extern "C" {
    #[doc = " Sets the speed of the motor on the given port."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port to set (from 1-8, 'a'-'h', 'A'-'H')"]
    #[doc = " \\param speed"]
    #[doc = "        The new signed speed; -127 is full reverse and 127 is full forward,"]
    #[doc = "        with 0 being off"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn adi_motor_set(port: u8, speed: i8) -> i32;
}
extern "C" {
    #[doc = " Gets the last set speed of the motor on the given port."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port to get (from 1-8, 'a'-'h', 'A'-'H')"]
    #[doc = ""]
    #[doc = " \\return The last set speed of the motor on the given port"]
    pub fn adi_motor_get(port: u8) -> i32;
}
extern "C" {
    #[doc = " Stops the motor on the given port."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port to set (from 1-8, 'a'-'h', 'A'-'H')"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn adi_motor_stop(port: u8) -> i32;
}
#[doc = " Reference type for an initialized encoder."]
#[doc = ""]
#[doc = " This merely contains the port number for the encoder, unlike its use as an"]
#[doc = " object to store encoder data in PROS 2."]
pub type adi_encoder_t = i32;
extern "C" {
    #[doc = " Gets the number of ticks recorded by the encoder."]
    #[doc = ""]
    #[doc = " There are 360 ticks in one revolution."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an encoder"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param enc"]
    #[doc = "        The adi_encoder_t object from adi_encoder_init() to read"]
    #[doc = ""]
    #[doc = " \\return The signed and cumulative number of counts since the last start or"]
    #[doc = " reset"]
    pub fn adi_encoder_get(enc: adi_encoder_t) -> i32;
}
extern "C" {
    #[doc = " Creates an encoder object and configures the specified ports accordingly."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an encoder"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param port_top"]
    #[doc = "        The \"top\" wire from the encoder sensor with the removable cover side"]
    #[doc = "        up. This should be in port 1, 3, 5, or 7 ('A', 'C', 'E', or 'G')."]
    #[doc = " \\param port_bottom"]
    #[doc = "        The \"bottom\" wire from the encoder sensor"]
    #[doc = " \\param reverse"]
    #[doc = "        If \"true\", the sensor will count in the opposite direction"]
    #[doc = ""]
    #[doc = " \\return An adi_encoder_t object to be stored and used for later calls to"]
    #[doc = " encoder functions"]
    pub fn adi_encoder_init(port_top: u8, port_bottom: u8, reverse: bool) -> adi_encoder_t;
}
extern "C" {
    #[doc = " Sets the encoder value to zero."]
    #[doc = ""]
    #[doc = " It is safe to use this method while an encoder is enabled. It is not"]
    #[doc = " necessary to call this method before stopping or starting an encoder."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an encoder"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param enc"]
    #[doc = "        The adi_encoder_t object from adi_encoder_init() to reset"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn adi_encoder_reset(enc: adi_encoder_t) -> i32;
}
extern "C" {
    #[doc = " Disables the encoder and voids the configuration on its ports."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an encoder"]
    #[doc = ""]
    #[doc = " \\param enc"]
    #[doc = "        The adi_encoder_t object from adi_encoder_init() to stop"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn adi_encoder_shutdown(enc: adi_encoder_t) -> i32;
}
#[doc = " Reference type for an initialized ultrasonic."]
#[doc = ""]
#[doc = " This merely contains the port number for the ultrasonic, unlike its use as an"]
#[doc = " object to store ultrasonic data in PROS 2."]
pub type adi_ultrasonic_t = i32;
extern "C" {
    #[doc = " Gets the current ultrasonic sensor value in centimeters."]
    #[doc = ""]
    #[doc = " If no object was found, zero is returned. If the ultrasonic sensor was never"]
    #[doc = " started, the return value is undefined. Round and fluffy objects can cause"]
    #[doc = " inaccurate values to be returned."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an ultrasonic"]
    #[doc = ""]
    #[doc = " \\param ult"]
    #[doc = "        The adi_ultrasonic_t object from adi_ultrasonic_init() to read"]
    #[doc = ""]
    #[doc = " \\return The distance to the nearest object in m^-4 (10000 indicates 1 meter),"]
    #[doc = " measured from the sensor's mounting points."]
    pub fn adi_ultrasonic_get(ult: adi_ultrasonic_t) -> i32;
}
extern "C" {
    #[doc = " Creates an ultrasonic object and configures the specified ports accordingly."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an ultrasonic"]
    #[doc = ""]
    #[doc = " \\param port_ping"]
    #[doc = "        The port connected to the orange OUTPUT cable. This should be in port"]
    #[doc = "        1, 3, 5, or 7 ('A', 'C', 'E', 'G')."]
    #[doc = " \\param port_echo"]
    #[doc = "        The port connected to the yellow INPUT cable. This should be in the"]
    #[doc = "        next highest port following port_ping."]
    #[doc = ""]
    #[doc = " \\return An adi_ultrasonic_t object to be stored and used for later calls to"]
    #[doc = " ultrasonic functions"]
    pub fn adi_ultrasonic_init(port_ping: u8, port_echo: u8) -> adi_ultrasonic_t;
}
extern "C" {
    #[doc = " Disables the ultrasonic sensor and voids the configuration on its ports."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as an ultrasonic"]
    #[doc = ""]
    #[doc = " \\param ult"]
    #[doc = "        The adi_ultrasonic_t object from adi_ultrasonic_init() to stop"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn adi_ultrasonic_shutdown(ult: adi_ultrasonic_t) -> i32;
}
#[doc = " Reference type for an initialized gyroscope."]
#[doc = ""]
#[doc = " This merely contains the port number for the gyroscope, unlike its use as an"]
#[doc = " object to store gyro data in PROS 2."]
pub type adi_gyro_t = i32;
extern "C" {
    #[doc = " Gets the current gyro angle in tenths of a degree. Unless a multiplier is"]
    #[doc = " applied to the gyro, the return value will be a whole number representing"]
    #[doc = " the number of degrees of rotation times 10."]
    #[doc = ""]
    #[doc = " There are 360 degrees in a circle, thus the gyro will return 3600 for one"]
    #[doc = " whole rotation."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as a gyro"]
    #[doc = ""]
    #[doc = " \\param gyro"]
    #[doc = "        The adi_gyro_t object for which the angle will be returned"]
    #[doc = ""]
    #[doc = " \\return The gyro angle in degrees."]
    pub fn adi_gyro_get(gyro: adi_gyro_t) -> f64;
}
extern "C" {
    #[doc = " Initializes a gyroscope on the given port. If the given port has not"]
    #[doc = " previously been configured as a gyro, then this function starts a 1300 ms"]
    #[doc = " calibration period."]
    #[doc = ""]
    #[doc = " It is highly recommended that this function be called from initialize() when"]
    #[doc = " the robot is stationary to ensure proper calibration."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as a gyro"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port to initialize as a gyro (from 1-8, 'a'-'h', 'A'-'H')"]
    #[doc = " \\param multiplier"]
    #[doc = "        A scalar value that will be multiplied by the gyro heading value"]
    #[doc = "        supplied by the ADI"]
    #[doc = ""]
    #[doc = " \\return An adi_gyro_t object containing the given port, or PROS_ERR if the"]
    #[doc = " initialization failed."]
    pub fn adi_gyro_init(port: u8, multiplier: f64) -> adi_gyro_t;
}
extern "C" {
    #[doc = " Resets the gyroscope value to zero."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as a gyro"]
    #[doc = ""]
    #[doc = " \\param gyro"]
    #[doc = "        The adi_gyro_t object for which the angle will be returned"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn adi_gyro_reset(gyro: adi_gyro_t) -> i32;
}
extern "C" {
    #[doc = " Disables the gyro and voids the configuration on its port."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as a gyro"]
    #[doc = ""]
    #[doc = " \\param gyro"]
    #[doc = "        The adi_gyro_t object to be shut down"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn adi_gyro_shutdown(gyro: adi_gyro_t) -> i32;
}
#[doc = " Reference type for an initialized potentiometer."]
#[doc = ""]
#[doc = " This merely contains the port number for the potentiometer, unlike its use as an"]
#[doc = " object to store potentiometer data in PROS 2."]
pub type adi_potentiometer_t = i32;
extern "C" {
    #[doc = " Initializes a potentiometer on the given port of the original potentiometer."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as a potentiometer"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port to initialize as a gyro (from 1-8, 'a'-'h', 'A'-'H')"]
    #[doc = ""]
    #[doc = " \\return An adi_potentiometer_t object containing the given port, or PROS_ERR if the"]
    #[doc = " initialization failed."]
    pub fn adi_potentiometer_init(port: u8) -> adi_potentiometer_t;
}
extern "C" {
    #[doc = " Initializes a potentiometer on the given port."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as a potentiometer"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port to initialize as a gyro (from 1-8, 'a'-'h', 'A'-'H')"]
    #[doc = " \\param potentiometer_type"]
    #[doc = "        An adi_potentiometer_type_e_t enum value specifying the potentiometer version type"]
    #[doc = ""]
    #[doc = " \\return An adi_potentiometer_t object containing the given port, or PROS_ERR if the"]
    #[doc = " initialization failed."]
    pub fn adi_potentiometer_type_init(
        port: u8,
        potentiometer_type: adi_potentiometer_type_e_t,
    ) -> adi_potentiometer_t;
}
extern "C" {
    #[doc = " Gets the current potentiometer angle in tenths of a degree."]
    #[doc = ""]
    #[doc = " The original potentiometer rotates 250 degrees thus returning an angle between 0-250 degrees."]
    #[doc = " Potentiometer V2 rotates 330 degrees thus returning an angle between 0-330 degrees."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EADDRINUSE - The port is not configured as a potentiometer"]
    #[doc = ""]
    #[doc = " \\param potentiometer"]
    #[doc = "        The adi_potentiometer_t object for which the angle will be returned"]
    #[doc = ""]
    #[doc = " \\return The potentiometer angle in degrees."]
    pub fn adi_potentiometer_get_angle(potentiometer: adi_potentiometer_t) -> f64;
}
#[doc = " Reference type for an initialized addressable led."]
#[doc = ""]
#[doc = " This merely contains the port number for the led, unlike its use as an"]
#[doc = " object to store led data in PROS 2."]
pub type adi_led_t = i32;
extern "C" {
    #[doc = " Initializes a led on the given port of the original led."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EINVAL - The ADI port given is not a valid port as defined below"]
    #[doc = " EADDRINUSE - The port is not configured for ADI output"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The ADI port to initialize as a led (from 1-8, 'a'-'h', 'A'-'H')"]
    #[doc = ""]
    #[doc = " \\return An adi_led_t object containing the given port, or PROS_ERR if the"]
    #[doc = " initialization failed, setting errno"]
    pub fn adi_led_init(port: u8) -> adi_led_t;
}
extern "C" {
    #[doc = " @brief Clear the entire led strip of color"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EINVAL - A given value is not correct, or the buffer is null"]
    #[doc = " EADDRINUSE - The port is not configured for ADI output"]
    #[doc = ""]
    #[doc = " @param led port of type adi_led_t"]
    #[doc = " @param buffer array of colors in format 0xRRGGBB, recommended that individual RGB value not to exceed 0x80 due to current draw"]
    #[doc = " @param buffer_length length of buffer to clear"]
    #[doc = " @return PROS_SUCCESS if successful, PROS_ERR if not"]
    pub fn adi_led_clear_all(led: adi_led_t, buffer: *mut u32, buffer_length: u32) -> i32;
}
extern "C" {
    #[doc = " @brief Set the entire led strip using the colors contained in the buffer"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EINVAL - A given value is not correct, or the buffer is null"]
    #[doc = " EADDRINUSE - The port is not configured for ADI output"]
    #[doc = ""]
    #[doc = " @param led port of type adi_led_t"]
    #[doc = " @param buffer array of colors in format 0xRRGGBB, recommended that individual RGB value not to exceed 0x80 due to current draw"]
    #[doc = " @param buffer_length length of buffer to clear"]
    #[doc = " @return PROS_SUCCESS if successful, PROS_ERR if not"]
    pub fn adi_led_set(led: adi_led_t, buffer: *mut u32, buffer_length: u32) -> i32;
}
extern "C" {
    #[doc = " @brief Set the entire led strip to one color"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EINVAL - A given value is not correct, or the buffer is null"]
    #[doc = " EADDRINUSE - The port is not configured for ADI output"]
    #[doc = ""]
    #[doc = " @param led port of type adi_led_t"]
    #[doc = " @param buffer array of colors in format 0xRRGGBB, recommended that individual RGB value not to exceed 0x80 due to current draw"]
    #[doc = " @param buffer_length length of buffer to clear"]
    #[doc = " @param color color to set all the led strip value to"]
    #[doc = " @return PROS_SUCCESS if successful, PROS_ERR if not"]
    pub fn adi_led_set_all(led: adi_led_t, buffer: *mut u32, buffer_length: u32, color: u32)
        -> i32;
}
extern "C" {
    #[doc = " @brief Set one pixel on the led strip"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EINVAL - A given value is not correct, or the buffer is null"]
    #[doc = " EADDRINUSE - The port is not configured for ADI output"]
    #[doc = ""]
    #[doc = " @param led port of type adi_led_t"]
    #[doc = " @param buffer array of colors in format 0xRRGGBB, recommended that individual RGB value not to exceed 0x80 due to current draw"]
    #[doc = " @param buffer_length length of the input buffer"]
    #[doc = " @param color color to clear all the led strip to"]
    #[doc = " @param pixel_position position of the pixel to clear"]
    #[doc = " @return PROS_SUCCESS if successful, PROS_ERR if not"]
    pub fn adi_led_set_pixel(
        led: adi_led_t,
        buffer: *mut u32,
        buffer_length: u32,
        color: u32,
        pixel_position: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Clear one pixel on the led strip"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of ADI Ports"]
    #[doc = " EINVAL - A given value is not correct, or the buffer is null"]
    #[doc = " EADDRINUSE - The port is not configured for ADI output"]
    #[doc = ""]
    #[doc = " @param led port of type adi_led_t"]
    #[doc = " @param buffer array of colors in format 0xRRGGBB, recommended that individual RGB value not to exceed 0x80 due to current draw"]
    #[doc = " @param buffer_length length of the input buffer"]
    #[doc = " @param pixel_position position of the pixel to clear"]
    #[doc = " @return PROS_SUCCESS if successful, PROS_ERR if not"]
    pub fn adi_led_clear_pixel(
        led: adi_led_t,
        buffer: *mut u32,
        buffer_length: u32,
        pixel_position: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " Get the currently measured distance from the sensor in mm"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Distance Sensor"]
    #[doc = ""]
    #[doc = " \\param  port The V5 Distance Sensor port number from 1-21"]
    #[doc = " \\return The distance value or PROS_ERR if the operation failed, setting"]
    #[doc = " errno."]
    pub fn distance_get(port: u8) -> i32;
}
extern "C" {
    #[doc = " Get the confidence in the distance reading"]
    #[doc = ""]
    #[doc = " This is a value that has a range of 0 to 63. 63 means high confidence,"]
    #[doc = " lower values imply less confidence. Confidence is only available"]
    #[doc = " when distance is > 200mm (the value 10 is returned in this scenario)."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Distance Sensor"]
    #[doc = ""]
    #[doc = " \\param  port The V5 Distance Sensor port number from 1-21"]
    #[doc = " \\return The confidence value or PROS_ERR if the operation failed, setting"]
    #[doc = " errno."]
    pub fn distance_get_confidence(port: u8) -> i32;
}
extern "C" {
    #[doc = " Get the current guess at relative object size"]
    #[doc = ""]
    #[doc = " This is a value that has a range of 0 to 400."]
    #[doc = " A 18\" x 30\" grey card will return a value of approximately 75"]
    #[doc = " in typical room lighting."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Distance Sensor"]
    #[doc = ""]
    #[doc = " \\param  port The V5 Distance Sensor port number from 1-21"]
    #[doc = " \\return The size value or PROS_ERR if the operation failed, setting"]
    #[doc = " errno."]
    pub fn distance_get_object_size(port: u8) -> i32;
}
extern "C" {
    #[doc = " Get the object velocity in m/s"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Distance Sensor"]
    #[doc = ""]
    #[doc = " \\param  port The V5 Distance Sensor port number from 1-21"]
    #[doc = " \\return The velocity value or PROS_ERR if the operation failed, setting"]
    #[doc = " errno."]
    pub fn distance_get_object_velocity(port: u8) -> f64;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct gps_status_s {
    #[doc = "< X Position (meters)"]
    pub x: f64,
    #[doc = "< Y Position (meters)"]
    pub y: f64,
    #[doc = "< Percieved Pitch based on GPS + IMU"]
    pub pitch: f64,
    #[doc = "< Percieved Roll based on GPS + IMU"]
    pub roll: f64,
    #[doc = "< Percieved Yaw based on GPS + IMU"]
    pub yaw: f64,
}
#[test]
fn bindgen_test_layout_gps_status_s() {
    const UNINIT: ::std::mem::MaybeUninit<gps_status_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gps_status_s>(),
        40usize,
        concat!("Size of: ", stringify!(gps_status_s))
    );
    assert_eq!(
        ::std::mem::align_of::<gps_status_s>(),
        1usize,
        concat!("Alignment of ", stringify!(gps_status_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gps_status_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gps_status_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gps_status_s),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roll) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gps_status_s),
            "::",
            stringify!(roll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yaw) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gps_status_s),
            "::",
            stringify!(yaw)
        )
    );
}
pub type gps_status_s_t = gps_status_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gps_raw_s {
    #[doc = "< Percieved Pitch based on GPS + IMU"]
    pub x: f64,
    #[doc = "< Percieved Roll based on GPS + IMU"]
    pub y: f64,
    #[doc = "< Percieved Yaw based on GPS + IMU"]
    pub z: f64,
}
#[test]
fn bindgen_test_layout_gps_raw_s() {
    const UNINIT: ::std::mem::MaybeUninit<gps_raw_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gps_raw_s>(),
        24usize,
        concat!("Size of: ", stringify!(gps_raw_s))
    );
    assert_eq!(
        ::std::mem::align_of::<gps_raw_s>(),
        8usize,
        concat!("Alignment of ", stringify!(gps_raw_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gps_raw_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gps_raw_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gps_raw_s),
            "::",
            stringify!(z)
        )
    );
}
pub type gps_accel_s_t = gps_raw_s;
pub type gps_gyro_s_t = gps_raw_s;
extern "C" {
    #[doc = " Set the GPS's offset relative to the center of turning in meters,"]
    #[doc = " as well as its initial position."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = " \\param  xOffset"]
    #[doc = " \t\t\t\t Cartesian 4-Quadrant X offset from center of turning (meters)"]
    #[doc = " \\param  yOffset"]
    #[doc = " \t\t\t\t Cartesian 4-Quadrant Y offset from center of turning (meters)"]
    #[doc = " \\param  xInitial"]
    #[doc = " \t\t\t\t Initial 4-Quadrant X Position, with (0,0) being at the center of the field (meters)"]
    #[doc = " \\param  yInitial"]
    #[doc = " \t\t\t\t Initial 4-Quadrant Y Position, with (0,0) being at the center of the field (meters)"]
    #[doc = " \\param  headingInitial"]
    #[doc = "  \t\t\t Heading with 0 being north on the field, in degrees [0,360) going clockwise"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn gps_initialize_full(
        port: u8,
        xInitial: f64,
        yInitial: f64,
        headingInitial: f64,
        xOffset: f64,
        yOffset: f64,
    ) -> i32;
}
extern "C" {
    #[doc = " Set the GPS's offset relative to the center of turning in meters."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = " \\param  xOffset"]
    #[doc = " \t\t\t\t Cartesian 4-Quadrant X offset from center of turning (meters)"]
    #[doc = " \\param  yOffset"]
    #[doc = " \t\t\t\t Cartesian 4-Quadrant Y offset from center of turning (meters)"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn gps_set_offset(port: u8, xOffset: f64, yOffset: f64) -> i32;
}
extern "C" {
    #[doc = " Get the GPS's location relative to the center of turning/origin in meters."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = " \\param  xOffset"]
    #[doc = " \t\t\t\t Pointer to cartesian 4-Quadrant X offset from center of turning (meters)"]
    #[doc = " \\param  yOffset"]
    #[doc = " \t\t\t\t Pointer to cartesian 4-Quadrant Y offset from center of turning (meters)"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn gps_get_offset(port: u8, xOffset: *mut f64, yOffset: *mut f64) -> i32;
}
extern "C" {
    #[doc = " Sets the robot's location relative to the center of the field in meters."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = " \\param  xInitial"]
    #[doc = " \t\t\t\t Initial 4-Quadrant X Position, with (0,0) being at the center of the field (meters)"]
    #[doc = " \\param  yInitial"]
    #[doc = " \t\t\t\t Initial 4-Quadrant Y Position, with (0,0) being at the center of the field (meters)"]
    #[doc = " \\param  headingInitial"]
    #[doc = "  \t\t\t Heading with 0 being north on the field, in degrees [0,360) going clockwise"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn gps_set_position(port: u8, xInitial: f64, yInitial: f64, headingInitial: f64) -> i32;
}
extern "C" {
    #[doc = " Set the GPS sensor's data rate in milliseconds, only applies to IMU on GPS."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = " \\param  rate"]
    #[doc = " \t\t\t\t Data rate in milliseconds (Minimum: 5 ms)"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn gps_set_data_rate(port: u8, rate: u32) -> i32;
}
extern "C" {
    #[doc = " Get the possible RMS (Root Mean Squared) error in meters for GPS position."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return Possible RMS (Root Mean Squared) error in meters for GPS position."]
    #[doc = " If the operation failed, returns PROS_ERR_F and errno is set."]
    pub fn gps_get_error(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the position and roll, yaw, and pitch of the GPS."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return A struct (gps_status_s_t) containing values mentioned above."]
    #[doc = " If the operation failed, all the structure's members are filled with"]
    #[doc = " PROS_ERR_F and errno is set."]
    pub fn gps_get_status(port: u8) -> gps_status_s_t;
}
extern "C" {
    #[doc = " Get the heading in [0,360) degree values."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The heading in [0,360) degree values. If the operation failed,"]
    #[doc = " returns PROS_ERR_F and errno is set."]
    pub fn gps_get_heading(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get the heading in the max double value and min double value scale."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The heading in [DOUBLE_MIN, DOUBLE_MAX] values. If the operation"]
    #[doc = " fails, returns PROS_ERR_F and errno is set."]
    pub fn gps_get_heading_raw(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the GPS sensor's elapsed rotation value"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = " \\return The elased heading in degrees. If the operation fails, returns"]
    #[doc = " PROS_ERR_F and errno is set."]
    pub fn gps_get_rotation(port: u8) -> f64;
}
extern "C" {
    #[doc = " Set the GPS sensor's rotation value to target value"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = " \\param  target"]
    #[doc = " \t\t\t\t Target rotation value to set rotation value to"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn gps_set_rotation(port: u8, target: f64) -> i32;
}
extern "C" {
    #[doc = " Tare the GPS sensor's rotation value"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn gps_tare_rotation(port: u8) -> i32;
}
extern "C" {
    #[doc = " Get the GPS's raw gyroscope values"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS port number from 1-21"]
    #[doc = " \\return The raw gyroscope values. If the operation failed, all the"]
    #[doc = " structure's members are filled with PROS_ERR_F and errno is set."]
    pub fn gps_get_gyro_rate(port: u8) -> gps_gyro_s_t;
}
extern "C" {
    #[doc = " Get the GPS's raw accelerometer values"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an GPS"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 GPS's port number from 1-21"]
    #[doc = " \\return The raw accelerometer values. If the operation failed, all the"]
    #[doc = " structure's members are filled with PROS_ERR_F and errno is set."]
    pub fn gps_get_accel(port: u8) -> gps_accel_s_t;
}
pub const imu_status_e_E_IMU_STATUS_CALIBRATING: imu_status_e = 1;
pub const imu_status_e_E_IMU_STATUS_ERROR: imu_status_e = 255;
pub type imu_status_e = ::std::os::raw::c_uint;
pub use self::imu_status_e as imu_status_e_t;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct quaternion_s {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_quaternion_s() {
    const UNINIT: ::std::mem::MaybeUninit<quaternion_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<quaternion_s>(),
        32usize,
        concat!("Size of: ", stringify!(quaternion_s))
    );
    assert_eq!(
        ::std::mem::align_of::<quaternion_s>(),
        1usize,
        concat!("Alignment of ", stringify!(quaternion_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quaternion_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quaternion_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quaternion_s),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quaternion_s),
            "::",
            stringify!(w)
        )
    );
}
pub type quaternion_s_t = quaternion_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imu_raw_s {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_imu_raw_s() {
    const UNINIT: ::std::mem::MaybeUninit<imu_raw_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imu_raw_s>(),
        24usize,
        concat!("Size of: ", stringify!(imu_raw_s))
    );
    assert_eq!(
        ::std::mem::align_of::<imu_raw_s>(),
        8usize,
        concat!("Alignment of ", stringify!(imu_raw_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imu_raw_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imu_raw_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(imu_raw_s),
            "::",
            stringify!(z)
        )
    );
}
pub type imu_gyro_s_t = imu_raw_s;
pub type imu_accel_s_t = imu_raw_s;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct euler_s {
    pub pitch: f64,
    pub roll: f64,
    pub yaw: f64,
}
#[test]
fn bindgen_test_layout_euler_s() {
    const UNINIT: ::std::mem::MaybeUninit<euler_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<euler_s>(),
        24usize,
        concat!("Size of: ", stringify!(euler_s))
    );
    assert_eq!(
        ::std::mem::align_of::<euler_s>(),
        1usize,
        concat!("Alignment of ", stringify!(euler_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(euler_s),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roll) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(euler_s),
            "::",
            stringify!(roll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yaw) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(euler_s),
            "::",
            stringify!(yaw)
        )
    );
}
pub type euler_s_t = euler_s;
extern "C" {
    #[doc = " Calibrate IMU"]
    #[doc = ""]
    #[doc = " Calibration takes approximately 2 seconds, but this function only blocks"]
    #[doc = " until the IMU status flag is set properly to E_IMU_STATUS_CALIBRATING,"]
    #[doc = " with a minimum blocking time of 5ms."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is already calibrating, or time out setting the status flag."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed setting errno."]
    pub fn imu_reset(port: u8) -> i32;
}
extern "C" {
    #[doc = " Calibrate IMU and Blocks while Calibrating"]
    #[doc = ""]
    #[doc = " Calibration takes approximately 2 seconds and blocks during this period,"]
    #[doc = " with a timeout for this operation being set a 3 seconds as a safety margin."]
    #[doc = " Like the other reset function, this function also blocks until the IMU"]
    #[doc = " status flag is set properly to E_IMU_STATUS_CALIBRATING, with a minimum"]
    #[doc = " blocking time of 5ms and a timeout of 1 second if it's never set."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is already calibrating, or time out setting the status flag."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed (timing out or port claim failure), setting errno."]
    pub fn imu_reset_blocking(port: u8) -> i32;
}
extern "C" {
    #[doc = " Set the Inertial Sensor's refresh interval in milliseconds."]
    #[doc = ""]
    #[doc = " The rate may be specified in increments of 5ms, and will be rounded down to"]
    #[doc = " the nearest increment. The minimum allowable refresh rate is 5ms. The default"]
    #[doc = " rate is 10ms."]
    #[doc = ""]
    #[doc = " As values are copied into the shared memory buffer only at 10ms intervals,"]
    #[doc = " setting this value to less than 10ms does not mean that you can poll the"]
    #[doc = " sensor's values any faster. However, it will guarantee that the data is as"]
    #[doc = " recent as possible."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "\t\t  The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\param rate The data refresh interval in milliseconds"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_set_data_rate(port: u8, rate: u32) -> i32;
}
extern "C" {
    #[doc = " Get the total number of degrees the Inertial Sensor has spun about the z-axis"]
    #[doc = ""]
    #[doc = " This value is theoretically unbounded. Clockwise rotations are represented"]
    #[doc = " with positive degree values, while counterclockwise rotations are represented"]
    #[doc = " with negative ones."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return The degree value or PROS_ERR_F if the operation failed, setting"]
    #[doc = " errno."]
    pub fn imu_get_rotation(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's heading relative to the initial direction of its"]
    #[doc = " x-axis"]
    #[doc = ""]
    #[doc = " This value is bounded by [0,360). Clockwise rotations are represented with"]
    #[doc = " positive degree values, while counterclockwise rotations are represented with"]
    #[doc = " negative ones."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return The degree value or PROS_ERR_F if the operation failed, setting"]
    #[doc = " errno."]
    pub fn imu_get_heading(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get a quaternion representing the Inertial Sensor's orientation"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return The quaternion representing the sensor's orientation. If the"]
    #[doc = " operation failed, all the quaternion's members are filled with PROS_ERR_F and"]
    #[doc = " errno is set."]
    pub fn imu_get_quaternion(port: u8) -> quaternion_s_t;
}
extern "C" {
    #[doc = " Get the Euler angles representing the Inertial Sensor's orientation"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return The Euler angles representing the sensor's orientation. If the"]
    #[doc = " operation failed, all the structure's members are filled with PROS_ERR_F and"]
    #[doc = " errno is set."]
    pub fn imu_get_euler(port: u8) -> euler_s_t;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's pitch angle bounded by (-180,180)"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return The pitch angle, or PROS_ERR_F if the operation failed, setting"]
    #[doc = " errno."]
    pub fn imu_get_pitch(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's roll angle bounded by (-180,180)"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return The roll angle, or PROS_ERR_F if the operation failed, setting errno."]
    pub fn imu_get_roll(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's yaw angle bounded by (-180,180)"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return The yaw angle, or PROS_ERR_F if the operation failed, setting errno."]
    pub fn imu_get_yaw(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's raw gyroscope values"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return The raw gyroscope values. If the operation failed, all the"]
    #[doc = " structure's members are filled with PROS_ERR_F and errno is set."]
    pub fn imu_get_gyro_rate(port: u8) -> imu_gyro_s_t;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's raw acceleroneter values"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return The raw accelerometer values. If the operation failed, all the"]
    #[doc = " structure's members are filled with PROS_ERR_F and errno is set."]
    pub fn imu_get_accel(port: u8) -> imu_accel_s_t;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's status"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return The Inertial Sensor's status code, or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_get_status(port: u8) -> imu_status_e_t;
}
extern "C" {
    #[doc = " Resets the current reading of the Inertial Sensor's heading to zero"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_tare_heading(port: u8) -> i32;
}
extern "C" {
    #[doc = " Resets the current reading of the Inertial Sensor's rotation to zero"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_tare_rotation(port: u8) -> i32;
}
extern "C" {
    #[doc = " Resets the current reading of the Inertial Sensor's pitch to zero"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_tare_pitch(port: u8) -> i32;
}
extern "C" {
    #[doc = " Resets the current reading of the Inertial Sensor's roll to zero"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_tare_roll(port: u8) -> i32;
}
extern "C" {
    #[doc = " Resets the current reading of the Inertial Sensor's yaw to zero"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_tare_yaw(port: u8) -> i32;
}
extern "C" {
    #[doc = " Reset all 3 euler values of the Inertial Sensor to 0."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_tare_euler(port: u8) -> i32;
}
extern "C" {
    #[doc = " Resets all 5 values of the Inertial Sensor to 0."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_tare(port: u8) -> i32;
}
extern "C" {
    #[doc = " Sets the current reading of the Inertial Sensor's euler values to"]
    #[doc = " target euler values. Will default to +/- 180 if target exceeds +/- 180."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\param  target"]
    #[doc = " \t\t\t\t Target euler values for the euler values to be set to"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_set_euler(port: u8, target: euler_s_t) -> i32;
}
extern "C" {
    #[doc = " Sets the current reading of the Inertial Sensor's rotation to target value"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\param  target"]
    #[doc = " \t\t\t\t Target value for the rotation value to be set to"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_set_rotation(port: u8, target: f64) -> i32;
}
extern "C" {
    #[doc = " Sets the current reading of the Inertial Sensor's heading to target value"]
    #[doc = " Target will default to 360 if above 360 and default to 0 if below 0."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\param  target"]
    #[doc = " \t\t\t\t Target value for the heading value to be set to"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_set_heading(port: u8, target: f64) -> i32;
}
extern "C" {
    #[doc = " Sets the current reading of the Inertial Sensor's pitch to target value"]
    #[doc = " Will default to +/- 180 if target exceeds +/- 180."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\param  target"]
    #[doc = " \t\t\t\t Target value for the pitch value to be set to"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_set_pitch(port: u8, target: f64) -> i32;
}
extern "C" {
    #[doc = " Sets the current reading of the Inertial Sensor's roll to target value"]
    #[doc = " Will default to +/- 180 if target exceeds +/- 180."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\param  target"]
    #[doc = " \t\t\t\t Target value for the roll value to be set to"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_set_roll(port: u8, target: f64) -> i32;
}
extern "C" {
    #[doc = " Sets the current reading of the Inertial Sensor's yaw to target value"]
    #[doc = " Will default to +/- 180 if target exceeds +/- 180."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Inertial Sensor"]
    #[doc = " EAGAIN - The sensor is still calibrating"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Inertial Sensor port number from 1-21"]
    #[doc = " \\param  target"]
    #[doc = " \t\t\t\t Target value for the yaw value to be set to"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn imu_set_yaw(port: u8, target: f64) -> i32;
}
pub const link_type_e_E_LINK_RECIEVER: link_type_e = 0;
pub const link_type_e_E_LINK_TRANSMITTER: link_type_e = 1;
pub const link_type_e_E_LINK_RX: link_type_e = 0;
pub const link_type_e_E_LINK_TX: link_type_e = 1;
pub type link_type_e = ::std::os::raw::c_uint;
pub use self::link_type_e as link_type_e_t;
extern "C" {
    #[doc = " Initializes a link on a radio port, with an indicated type. There might be a"]
    #[doc = " 1 to 2 second delay from when this function is called to when the link is initializes."]
    #[doc = " PROS currently only supports the use of one radio per brain."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a radio."]
    #[doc = " ENXIO - The sensor is still calibrating, or no link is connected via the radio."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "      The port of the radio for the intended link."]
    #[doc = " \\param link_id"]
    #[doc = "      Unique link ID in the form of a string, needs to be different from other links in"]
    #[doc = "      the area."]
    #[doc = " \\param type"]
    #[doc = "      Indicates whether the radio link on the brain is a transmitter or reciever,"]
    #[doc = "      with the transmitter having double the transmitting bandwidth as the recieving"]
    #[doc = "      end (1040 bytes/s vs 520 bytes/s)."]
    #[doc = ""]
    #[doc = " \\return PROS_ERR if initialization fails, 1 if the initialization succeeds."]
    pub fn link_init(port: u8, link_id: *const ::std::os::raw::c_char, type_: link_type_e_t)
        -> u32;
}
extern "C" {
    #[doc = " Initializes a link on a radio port, with an indicated type and the ability for"]
    #[doc = " vexlink to override the controller radio. There might be a 1 to 2 second delay"]
    #[doc = " from when this function is called to when the link is initializes."]
    #[doc = " PROS currently only supports the use of one radio per brain."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a radio."]
    #[doc = " ENXIO - The sensor is still calibrating, or no link is connected via the radio."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "      The port of the radio for the intended link."]
    #[doc = " \\param link_id"]
    #[doc = "      Unique link ID in the form of a string, needs to be different from other links in"]
    #[doc = "      the area."]
    #[doc = " \\param type"]
    #[doc = "      Indicates whether the radio link on the brain is a transmitter or reciever,"]
    #[doc = "      with the transmitter having double the transmitting bandwidth as the recieving"]
    #[doc = "      end (1040 bytes/s vs 520 bytes/s)."]
    #[doc = ""]
    #[doc = " \\return PROS_ERR if initialization fails, 1 if the initialization succeeds."]
    pub fn link_init_override(
        port: u8,
        link_id: *const ::std::os::raw::c_char,
        type_: link_type_e_t,
    ) -> u32;
}
extern "C" {
    #[doc = " Checks if a radio link on a port is active or not."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a radio."]
    #[doc = " ENXIO - The sensor is still calibrating, or no link is connected via the radio."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "      The port of the radio for the intended link."]
    #[doc = ""]
    #[doc = " \\return If a radio is connected to a port and it's connected to a link."]
    pub fn link_connected(port: u8) -> bool;
}
extern "C" {
    #[doc = " Returns the bytes of data available to be read"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a radio."]
    #[doc = " ENXIO - The sensor is still calibrating, or no link is connected via the radio."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "      The port of the radio for the intended link."]
    #[doc = ""]
    #[doc = " \\return PROS_ERR if port is not a link/radio, else the bytes available to be"]
    #[doc = " read by the user."]
    pub fn link_raw_receivable_size(port: u8) -> u32;
}
extern "C" {
    #[doc = " Returns the bytes of data available in transmission buffer."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a radio."]
    #[doc = " ENXIO - The sensor is still calibrating, or no link is connected via the radio."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "      The port of the radio for the intended link."]
    #[doc = ""]
    #[doc = " \\return PROS_ERR if port is not a link/radio,"]
    pub fn link_raw_transmittable_size(port: u8) -> u32;
}
extern "C" {
    #[doc = " Send raw serial data through vexlink."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a radio."]
    #[doc = " ENXIO - The sensor is still calibrating, or no link is connected via the radio."]
    #[doc = " EBUSY - The transmitter buffer is still busy with a previous transmission, and there is no"]
    #[doc = " room in the FIFO buffer (queue) to transmit the data."]
    #[doc = " EINVAL - The data given is NULL"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "      The port of the radio for the intended link."]
    #[doc = " \\param data"]
    #[doc = "      Buffer with data to send"]
    #[doc = " \\param data_size"]
    #[doc = "      Bytes of data to be read to the destination buffer"]
    #[doc = ""]
    #[doc = " \\return PROS_ERR if port is not a link, and the successfully transmitted"]
    #[doc = " data size if it succeeded."]
    pub fn link_transmit_raw(port: u8, data: *mut ::std::os::raw::c_void, data_size: u16) -> u32;
}
extern "C" {
    #[doc = " Receive raw serial data through vexlink."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a radio."]
    #[doc = " ENXIO - The sensor is still calibrating, or no link is connected via the radio."]
    #[doc = " EINVAL - The destination given is NULL, or the size given is larger than the FIFO buffer"]
    #[doc = " or destination buffer."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "      The port of the radio for the intended link."]
    #[doc = " \\param dest"]
    #[doc = "      Destination buffer to read data to"]
    #[doc = " \\param data_size"]
    #[doc = "      Bytes of data to be read to the destination buffer"]
    #[doc = ""]
    #[doc = " \\return PROS_ERR if port is not a link, and the successfully received"]
    #[doc = " data size if it succeeded."]
    pub fn link_receive_raw(port: u8, dest: *mut ::std::os::raw::c_void, data_size: u16) -> u32;
}
extern "C" {
    #[doc = " Send packeted message through vexlink, with a checksum and start byte."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a radio."]
    #[doc = " ENXIO - The sensor is still calibrating, or no link is connected via the radio."]
    #[doc = " EBUSY - The transmitter buffer is still busy with a previous transmission, and there is no"]
    #[doc = " room in the FIFO buffer (queue) to transmit the data."]
    #[doc = " EINVAL - The data given is NULL"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "      The port of the radio for the intended link."]
    #[doc = " \\param data"]
    #[doc = "      Buffer with data to send"]
    #[doc = " \\param data_size"]
    #[doc = "      Bytes of data to be read to the destination buffer"]
    #[doc = ""]
    #[doc = " \\return PROS_ERR if port is not a link, and the successfully transmitted"]
    #[doc = " data size if it succeeded."]
    pub fn link_transmit(port: u8, data: *mut ::std::os::raw::c_void, data_size: u16) -> u32;
}
extern "C" {
    #[doc = " Receive packeted message through vexlink, with a checksum and start byte."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a radio."]
    #[doc = " ENXIO - The sensor is still calibrating, or no link is connected via the radio."]
    #[doc = " EINVAL - The destination given is NULL, or the size given is larger than the FIFO buffer"]
    #[doc = " or destination buffer."]
    #[doc = " EBADMSG - Protocol error related to start byte, data size, or checksum."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "      The port of the radio for the intended link."]
    #[doc = " \\param dest"]
    #[doc = "      Destination buffer to read data to"]
    #[doc = " \\param data_size"]
    #[doc = "      Bytes of data to be read to the destination buffer"]
    #[doc = ""]
    #[doc = " \\return PROS_ERR if port is not a link or protocol error, and the successfully"]
    #[doc = " transmitted data size if it succeeded."]
    pub fn link_receive(port: u8, dest: *mut ::std::os::raw::c_void, data_size: u16) -> u32;
}
extern "C" {
    #[doc = " Clear the receive buffer of the link, and discarding the data."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a radio."]
    #[doc = " ENXIO - The sensor is still calibrating, or no link is connected via the radio."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "      The port of the radio for the intended link."]
    #[doc = ""]
    #[doc = " \\return PROS_ERR if port is not a link, and the successfully received"]
    #[doc = " data size if it succeeded."]
    pub fn link_clear_receive_buf(port: u8) -> u32;
}
extern "C" {
    pub fn competition_get_status() -> u8;
}
pub const controller_id_e_t_E_CONTROLLER_MASTER: controller_id_e_t = 0;
pub const controller_id_e_t_E_CONTROLLER_PARTNER: controller_id_e_t = 1;
pub type controller_id_e_t = ::std::os::raw::c_uint;
pub const controller_analog_e_t_E_CONTROLLER_ANALOG_LEFT_X: controller_analog_e_t = 0;
pub const controller_analog_e_t_E_CONTROLLER_ANALOG_LEFT_Y: controller_analog_e_t = 1;
pub const controller_analog_e_t_E_CONTROLLER_ANALOG_RIGHT_X: controller_analog_e_t = 2;
pub const controller_analog_e_t_E_CONTROLLER_ANALOG_RIGHT_Y: controller_analog_e_t = 3;
pub type controller_analog_e_t = ::std::os::raw::c_uint;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_L1: controller_digital_e_t = 6;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_L2: controller_digital_e_t = 7;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_R1: controller_digital_e_t = 8;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_R2: controller_digital_e_t = 9;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_UP: controller_digital_e_t = 10;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_DOWN: controller_digital_e_t = 11;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_LEFT: controller_digital_e_t = 12;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_RIGHT: controller_digital_e_t = 13;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_X: controller_digital_e_t = 14;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_B: controller_digital_e_t = 15;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_Y: controller_digital_e_t = 16;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_A: controller_digital_e_t = 17;
pub type controller_digital_e_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "                              Date and Time                               **/"]
    pub static mut baked_date: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut baked_time: *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct date_s_t {
    pub year: u16,
    pub day: u8,
    pub month: u8,
}
#[test]
fn bindgen_test_layout_date_s_t() {
    const UNINIT: ::std::mem::MaybeUninit<date_s_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<date_s_t>(),
        4usize,
        concat!("Size of: ", stringify!(date_s_t))
    );
    assert_eq!(
        ::std::mem::align_of::<date_s_t>(),
        2usize,
        concat!("Alignment of ", stringify!(date_s_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(date_s_t),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(date_s_t),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(date_s_t),
            "::",
            stringify!(month)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct time_s_t {
    pub hour: u8,
    pub min: u8,
    pub sec: u8,
    pub sec_hund: u8,
}
#[test]
fn bindgen_test_layout_time_s_t() {
    const UNINIT: ::std::mem::MaybeUninit<time_s_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<time_s_t>(),
        4usize,
        concat!("Size of: ", stringify!(time_s_t))
    );
    assert_eq!(
        ::std::mem::align_of::<time_s_t>(),
        1usize,
        concat!("Alignment of ", stringify!(time_s_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(time_s_t),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(time_s_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(time_s_t),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec_hund) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(time_s_t),
            "::",
            stringify!(sec_hund)
        )
    );
}
extern "C" {
    #[doc = " Checks if the controller is connected."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is"]
    #[doc = " given."]
    #[doc = " EACCES - Another resource is currently trying to access the controller port."]
    #[doc = ""]
    #[doc = " \\param id"]
    #[doc = "        The ID of the controller (e.g. the master or partner controller)."]
    #[doc = "        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER"]
    #[doc = ""]
    #[doc = " \\return 1 if the controller is connected, 0 otherwise"]
    pub fn controller_is_connected(id: controller_id_e_t) -> i32;
}
extern "C" {
    #[doc = " Gets the value of an analog channel (joystick) on a controller."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is"]
    #[doc = " given."]
    #[doc = " EACCES - Another resource is currently trying to access the controller port."]
    #[doc = ""]
    #[doc = " \\param id"]
    #[doc = "        The ID of the controller (e.g. the master or partner controller)."]
    #[doc = "        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER"]
    #[doc = " \\param channel"]
    #[doc = "        The analog channel to get."]
    #[doc = "        Must be one of ANALOG_LEFT_X, ANALOG_LEFT_Y, ANALOG_RIGHT_X,"]
    #[doc = "        ANALOG_RIGHT_Y"]
    #[doc = ""]
    #[doc = " \\return The current reading of the analog channel: [-127, 127]."]
    #[doc = " If the controller was not connected, then 0 is returned"]
    pub fn controller_get_analog(id: controller_id_e_t, channel: controller_analog_e_t) -> i32;
}
extern "C" {
    #[doc = " Gets the battery capacity of the given controller."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is"]
    #[doc = " given."]
    #[doc = " EACCES - Another resource is currently trying to access the controller port."]
    #[doc = ""]
    #[doc = " \\param id"]
    #[doc = "        The ID of the controller (e.g. the master or partner controller)."]
    #[doc = "        Must be one of E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER"]
    #[doc = ""]
    #[doc = " \\return The controller's battery capacity"]
    pub fn controller_get_battery_capacity(id: controller_id_e_t) -> i32;
}
extern "C" {
    #[doc = " Gets the battery level of the given controller."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is"]
    #[doc = " given."]
    #[doc = " EACCES - Another resource is currently trying to access the controller port."]
    #[doc = ""]
    #[doc = " \\param id"]
    #[doc = "        The ID of the controller (e.g. the master or partner controller)."]
    #[doc = "        Must be one of E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER"]
    #[doc = ""]
    #[doc = " \\return The controller's battery level"]
    pub fn controller_get_battery_level(id: controller_id_e_t) -> i32;
}
extern "C" {
    #[doc = " Checks if a digital channel (button) on the controller is currently pressed."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is"]
    #[doc = " given."]
    #[doc = " EACCES - Another resource is currently trying to access the controller port."]
    #[doc = ""]
    #[doc = " \\param id"]
    #[doc = "        The ID of the controller (e.g. the master or partner controller)."]
    #[doc = "        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER"]
    #[doc = " \\param button"]
    #[doc = "        The button to read."]
    #[doc = "        Must be one of DIGITAL_{RIGHT,DOWN,LEFT,UP,A,B,Y,X,R1,R2,L1,L2}"]
    #[doc = ""]
    #[doc = " \\return 1 if the button on the controller is pressed."]
    #[doc = " If the controller was not connected, then 0 is returned"]
    pub fn controller_get_digital(id: controller_id_e_t, button: controller_digital_e_t) -> i32;
}
extern "C" {
    #[doc = " Returns a rising-edge case for a controller button press."]
    #[doc = ""]
    #[doc = " This function is not thread-safe."]
    #[doc = " Multiple tasks polling a single button may return different results under the"]
    #[doc = " same circumstances, so only one task should call this function for any given"]
    #[doc = " button. E.g., Task A calls this function for buttons 1 and 2. Task B may call"]
    #[doc = " this function for button 3, but should not for buttons 1 or 2. A typical"]
    #[doc = " use-case for this function is to call inside opcontrol to detect new button"]
    #[doc = " presses, and not in any other tasks."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is"]
    #[doc = " given."]
    #[doc = " EACCES - Another resource is currently trying to access the controller port."]
    #[doc = ""]
    #[doc = " \\param id"]
    #[doc = "        The ID of the controller (e.g. the master or partner controller)."]
    #[doc = "        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER"]
    #[doc = " \\param button"]
    #[doc = " \t\t\t  The button to read. Must be one of"]
    #[doc = "        DIGITAL_{RIGHT,DOWN,LEFT,UP,A,B,Y,X,R1,R2,L1,L2}"]
    #[doc = ""]
    #[doc = " \\return 1 if the button on the controller is pressed and had not been pressed"]
    #[doc = " the last time this function was called, 0 otherwise."]
    pub fn controller_get_digital_new_press(
        id: controller_id_e_t,
        button: controller_digital_e_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets text to the controller LCD screen."]
    #[doc = ""]
    #[doc = " \\note Controller text setting is currently in beta, so continuous, fast"]
    #[doc = " updates will not work well."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is"]
    #[doc = " given."]
    #[doc = " EACCES - Another resource is currently trying to access the controller port."]
    #[doc = ""]
    #[doc = " \\param id"]
    #[doc = "        The ID of the controller (e.g. the master or partner controller)."]
    #[doc = "        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER"]
    #[doc = " \\param line"]
    #[doc = "        The line number at which the text will be displayed [0-2]"]
    #[doc = " \\param col"]
    #[doc = "        The column number at which the text will be displayed [0-14]"]
    #[doc = " \\param fmt"]
    #[doc = "        The format string to print to the controller"]
    #[doc = " \\param ..."]
    #[doc = "        The argument list for the format string"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn controller_print(
        id: controller_id_e_t,
        line: u8,
        col: u8,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> i32;
}
extern "C" {
    #[doc = " Sets text to the controller LCD screen."]
    #[doc = ""]
    #[doc = " \\note Controller text setting is currently in beta, so continuous, fast"]
    #[doc = " updates will not work well."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is"]
    #[doc = " given."]
    #[doc = " EACCES - Another resource is currently trying to access the controller port."]
    #[doc = ""]
    #[doc = " \\param id"]
    #[doc = "        The ID of the controller (e.g. the master or partner controller)."]
    #[doc = "        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER"]
    #[doc = " \\param line"]
    #[doc = "        The line number at which the text will be displayed [0-2]"]
    #[doc = " \\param col"]
    #[doc = "        The column number at which the text will be displayed [0-14]"]
    #[doc = " \\param str"]
    #[doc = "        The pre-formatted string to print to the controller"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn controller_set_text(
        id: controller_id_e_t,
        line: u8,
        col: u8,
        str_: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Clears an individual line of the controller screen."]
    #[doc = ""]
    #[doc = " \\note Controller text setting is currently in beta, so continuous, fast"]
    #[doc = " updates will not work well."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is"]
    #[doc = " given."]
    #[doc = " EACCES - Another resource is currently trying to access the controller port."]
    #[doc = ""]
    #[doc = " \\param id"]
    #[doc = "        The ID of the controller (e.g. the master or partner controller)."]
    #[doc = "        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER"]
    #[doc = " \\param line"]
    #[doc = "        The line number to clear [0-2]"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn controller_clear_line(id: controller_id_e_t, line: u8) -> i32;
}
extern "C" {
    #[doc = " Clears all of the lines on the controller screen."]
    #[doc = ""]
    #[doc = " \\note Controller text setting is currently in beta, so continuous, fast"]
    #[doc = " updates will not work well. On vexOS version 1.0.0 this function will block"]
    #[doc = " for 110ms."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is"]
    #[doc = " given."]
    #[doc = " EACCES - Another resource is currently trying to access the controller port."]
    #[doc = ""]
    #[doc = " \\param id"]
    #[doc = "        The ID of the controller (e.g. the master or partner controller)."]
    #[doc = "        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn controller_clear(id: controller_id_e_t) -> i32;
}
extern "C" {
    #[doc = " Rumble the controller."]
    #[doc = ""]
    #[doc = " \\note Controller rumble activation is currently in beta, so continuous, fast"]
    #[doc = " updates will not work well."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is"]
    #[doc = " given."]
    #[doc = " EACCES - Another resource is currently trying to access the controller port."]
    #[doc = ""]
    #[doc = " \\param id"]
    #[doc = "\t\t\t\tThe ID of the controller (e.g. the master or partner controller)."]
    #[doc = "\t\t\t\tMust be one of CONTROLLER_MASTER or CONTROLLER_PARTNER"]
    #[doc = " \\param rumble_pattern"]
    #[doc = "\t\t\t\tA string consisting of the characters '.', '-', and ' ', where dots"]
    #[doc = "\t\t\t\tare short rumbles, dashes are long rumbles, and spaces are pauses."]
    #[doc = "\t\t\t\tMaximum supported length is 8 characters."]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn controller_rumble(
        id: controller_id_e_t,
        rumble_pattern: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the current voltage of the battery, as reported by VEXos."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EACCES - Another resource is currently trying to access the battery port."]
    #[doc = ""]
    #[doc = " \\return The current voltage of the battery"]
    pub fn battery_get_voltage() -> i32;
}
extern "C" {
    #[doc = " Gets the current current of the battery, as reported by VEXos."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EACCES - Another resource is currently trying to access the battery port."]
    #[doc = ""]
    #[doc = " \\return The current current of the battery"]
    pub fn battery_get_current() -> i32;
}
extern "C" {
    #[doc = " Gets the current temperature of the battery, as reported by VEXos."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EACCES - Another resource is currently trying to access the battery port."]
    #[doc = ""]
    #[doc = " \\return The current temperature of the battery"]
    pub fn battery_get_temperature() -> f64;
}
extern "C" {
    #[doc = " Gets the current capacity of the battery, as reported by VEXos."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EACCES - Another resource is currently trying to access the battery port."]
    #[doc = ""]
    #[doc = " \\return The current capacity of the battery"]
    pub fn battery_get_capacity() -> f64;
}
extern "C" {
    #[doc = " Checks if the SD card is installed."]
    #[doc = ""]
    #[doc = " \\return 1 if the SD card is installed, 0 otherwise"]
    pub fn usd_is_installed() -> i32;
}
extern "C" {
    #[doc = " Sets the voltage for the motor from -127 to 127."]
    #[doc = ""]
    #[doc = " This is designed to map easily to the input from the controller's analog"]
    #[doc = " stick for simple opcontrol use. The actual behavior of the motor is analogous"]
    #[doc = " to use of motor_move_voltage(), or motorSet() from the PROS 2 API."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param voltage"]
    #[doc = "        The new motor voltage from -127 to 127"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_move(port: u8, voltage: i32) -> i32;
}
extern "C" {
    #[doc = " Stops the motor using the currently configured brake mode."]
    #[doc = ""]
    #[doc = " This function sets motor velocity to zero, which will cause it to act"]
    #[doc = " according to the set brake mode. If brake mode is set to MOTOR_BRAKE_HOLD,"]
    #[doc = " this function may behave differently than calling motor_move_absolute(port, 0)"]
    #[doc = " or motor_move_relative(port, 0)."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_brake(port: u8) -> i32;
}
extern "C" {
    #[doc = " Sets the target absolute position for the motor to move to."]
    #[doc = ""]
    #[doc = " This movement is relative to the position of the motor when initialized or"]
    #[doc = " the position when it was most recently reset with motor_set_zero_position()."]
    #[doc = ""]
    #[doc = " \\note This function simply sets the target for the motor, it does not block"]
    #[doc = " program execution until the movement finishes."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param position"]
    #[doc = "        The absolute position to move to in the motor's encoder units"]
    #[doc = " \\param velocity"]
    #[doc = "        The maximum allowable velocity for the movement in RPM"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_move_absolute(port: u8, position: f64, velocity: i32) -> i32;
}
extern "C" {
    #[doc = " Sets the relative target position for the motor to move to."]
    #[doc = ""]
    #[doc = " This movement is relative to the current position of the motor as given in"]
    #[doc = " motor_get_position(). Providing 10.0 as the position parameter would result"]
    #[doc = " in the motor moving clockwise 10 units, no matter what the current position"]
    #[doc = " is."]
    #[doc = ""]
    #[doc = " \\note This function simply sets the target for the motor, it does not block"]
    #[doc = " program execution until the movement finishes."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param position"]
    #[doc = "        The relative position to move to in the motor's encoder units"]
    #[doc = " \\param velocity"]
    #[doc = "        The maximum allowable velocity for the movement in RPM"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_move_relative(port: u8, position: f64, velocity: i32) -> i32;
}
extern "C" {
    #[doc = " Sets the velocity for the motor."]
    #[doc = ""]
    #[doc = " This velocity corresponds to different actual speeds depending on the gearset"]
    #[doc = " used for the motor. This results in a range of +-100 for E_MOTOR_GEARSET_36,"]
    #[doc = " +-200 for E_MOTOR_GEARSET_18, and +-600 for E_MOTOR_GEARSET_6. The velocity"]
    #[doc = " is held with PID to ensure consistent speed, as opposed to setting the"]
    #[doc = " motor's voltage."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param velocity"]
    #[doc = "        The new motor velocity from +-100, +-200, or +-600 depending on the"]
    #[doc = "        motor's gearset"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_move_velocity(port: u8, velocity: i32) -> i32;
}
extern "C" {
    #[doc = " Sets the output voltage for the motor from -12000 to 12000 in millivolts"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param voltage"]
    #[doc = "        The new voltage value from -12000 to 12000"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_move_voltage(port: u8, voltage: i32) -> i32;
}
extern "C" {
    #[doc = " Changes the output velocity for a profiled movement (motor_move_absolute or"]
    #[doc = " motor_move_relative). This will have no effect if the motor is not following"]
    #[doc = " a profiled movement."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param velocity"]
    #[doc = "        The new motor velocity from +-100, +-200, or +-600 depending on the"]
    #[doc = "        motor's gearset"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_modify_profiled_velocity(port: u8, velocity: i32) -> i32;
}
extern "C" {
    #[doc = " Gets the target position set for the motor by the user."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The target position in its encoder units or PROS_ERR_F if the"]
    #[doc = " operation failed, setting errno."]
    pub fn motor_get_target_position(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the velocity commanded to the motor by the user."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The commanded motor velocity from +-100, +-200, or +-600, or PROS_ERR"]
    #[doc = " if the operation failed, setting errno."]
    pub fn motor_get_target_velocity(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the actual velocity of the motor."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The motor's actual velocity in RPM or PROS_ERR_F if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_get_actual_velocity(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the current drawn by the motor in mA."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The motor's current in mA or PROS_ERR if the operation failed,"]
    #[doc = " setting errno."]
    pub fn motor_get_current_draw(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the direction of movement for the motor."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return 1 for moving in the positive direction, -1 for moving in the"]
    #[doc = " negative direction, or PROS_ERR if the operation failed, setting errno."]
    pub fn motor_get_direction(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the efficiency of the motor in percent."]
    #[doc = ""]
    #[doc = " An efficiency of 100% means that the motor is moving electrically while"]
    #[doc = " drawing no electrical power, and an efficiency of 0% means that the motor"]
    #[doc = " is drawing power but not moving."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The motor's efficiency in percent or PROS_ERR_F if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_get_efficiency(port: u8) -> f64;
}
extern "C" {
    #[doc = " Checks if the motor is drawing over its current limit."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return 1 if the motor's current limit is being exceeded and 0 if the current"]
    #[doc = " limit is not exceeded, or PROS_ERR if the operation failed, setting errno."]
    pub fn motor_is_over_current(port: u8) -> i32;
}
extern "C" {
    #[doc = " Checks if the motor's temperature is above its limit."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return 1 if the temperature limit is exceeded and 0 if the the temperature"]
    #[doc = " is below the limit, or PROS_ERR if the operation failed, setting errno."]
    pub fn motor_is_over_temp(port: u8) -> i32;
}
extern "C" {
    #[doc = " Checks if the motor is stopped."]
    #[doc = ""]
    #[doc = " \\note Although this function forwards data from the motor, the motor"]
    #[doc = " presently does not provide any value. This function returns PROS_ERR with"]
    #[doc = " errno set to ENOSYS."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return 1 if the motor is not moving, 0 if the motor is moving, or PROS_ERR"]
    #[doc = " if the operation failed, setting errno"]
    pub fn motor_is_stopped(port: u8) -> i32;
}
extern "C" {
    #[doc = " Checks if the motor is at its zero position."]
    #[doc = ""]
    #[doc = " \\note Although this function forwards data from the motor, the motor"]
    #[doc = " presently does not provide any value. This function returns PROS_ERR with"]
    #[doc = " errno set to ENOSYS."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return 1 if the motor is at zero absolute position, 0 if the motor has"]
    #[doc = " moved from its absolute zero, or PROS_ERR if the operation failed,"]
    #[doc = " setting errno"]
    pub fn motor_get_zero_position_flag(port: u8) -> i32;
}
pub const motor_fault_e_E_MOTOR_FAULT_NO_FAULTS: motor_fault_e = 0;
pub const motor_fault_e_E_MOTOR_FAULT_MOTOR_OVER_TEMP: motor_fault_e = 1;
pub const motor_fault_e_E_MOTOR_FAULT_DRIVER_FAULT: motor_fault_e = 2;
pub const motor_fault_e_E_MOTOR_FAULT_OVER_CURRENT: motor_fault_e = 4;
pub const motor_fault_e_E_MOTOR_FAULT_DRV_OVER_CURRENT: motor_fault_e = 8;
pub type motor_fault_e = ::std::os::raw::c_uint;
pub use self::motor_fault_e as motor_fault_e_t;
extern "C" {
    #[doc = " Gets the faults experienced by the motor."]
    #[doc = ""]
    #[doc = " Compare this bitfield to the bitmasks in motor_fault_e_t."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return A bitfield containing the motor's faults."]
    pub fn motor_get_faults(port: u8) -> u32;
}
pub const motor_flag_e_E_MOTOR_FLAGS_NONE: motor_flag_e = 0;
pub const motor_flag_e_E_MOTOR_FLAGS_BUSY: motor_flag_e = 1;
pub const motor_flag_e_E_MOTOR_FLAGS_ZERO_VELOCITY: motor_flag_e = 2;
pub const motor_flag_e_E_MOTOR_FLAGS_ZERO_POSITION: motor_flag_e = 4;
pub type motor_flag_e = ::std::os::raw::c_uint;
pub use self::motor_flag_e as motor_flag_e_t;
extern "C" {
    #[doc = " Gets the flags set by the motor's operation."]
    #[doc = ""]
    #[doc = " Compare this bitfield to the bitmasks in motor_flag_e_t."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return A bitfield containing the motor's flags."]
    pub fn motor_get_flags(port: u8) -> u32;
}
extern "C" {
    #[doc = " Gets the raw encoder count of the motor at a given timestamp."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param[in] timestamp"]
    #[doc = "            A pointer to a time in milliseconds for which the encoder count"]
    #[doc = "            will be returned. If NULL, the timestamp at which the encoder"]
    #[doc = "            count was read will not be supplied"]
    #[doc = ""]
    #[doc = " \\return The raw encoder count at the given timestamp or PROS_ERR if the"]
    #[doc = " operation failed."]
    pub fn motor_get_raw_position(port: u8, timestamp: *mut u32) -> i32;
}
extern "C" {
    #[doc = " Gets the absolute position of the motor in its encoder units."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The motor's absolute position in its encoder units or PROS_ERR_F"]
    #[doc = " if the operation failed, setting errno."]
    pub fn motor_get_position(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the power drawn by the motor in Watts."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The motor's power draw in Watts or PROS_ERR_F if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_get_power(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the temperature of the motor in degrees Celsius."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The motor's temperature in degrees Celsius or PROS_ERR_F if the"]
    #[doc = " operation failed, setting errno."]
    pub fn motor_get_temperature(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the torque generated by the motor in Newton Meters (Nm)."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The motor's torque in Nm or PROS_ERR_F if the operation failed,"]
    #[doc = " setting errno."]
    pub fn motor_get_torque(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the voltage delivered to the motor in millivolts."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The motor's voltage in mV or PROS_ERR_F if the operation failed,"]
    #[doc = " setting errno."]
    pub fn motor_get_voltage(port: u8) -> i32;
}
pub const motor_brake_mode_e_E_MOTOR_BRAKE_COAST: motor_brake_mode_e = 0;
pub const motor_brake_mode_e_E_MOTOR_BRAKE_BRAKE: motor_brake_mode_e = 1;
pub const motor_brake_mode_e_E_MOTOR_BRAKE_HOLD: motor_brake_mode_e = 2;
pub const motor_brake_mode_e_E_MOTOR_BRAKE_INVALID: motor_brake_mode_e = 2147483647;
#[doc = " Indicates the current 'brake mode' of a motor."]
pub type motor_brake_mode_e = ::std::os::raw::c_uint;
#[doc = " Indicates the current 'brake mode' of a motor."]
pub use self::motor_brake_mode_e as motor_brake_mode_e_t;
pub const motor_encoder_units_e_E_MOTOR_ENCODER_DEGREES: motor_encoder_units_e = 0;
pub const motor_encoder_units_e_E_MOTOR_ENCODER_ROTATIONS: motor_encoder_units_e = 1;
pub const motor_encoder_units_e_E_MOTOR_ENCODER_COUNTS: motor_encoder_units_e = 2;
pub const motor_encoder_units_e_E_MOTOR_ENCODER_INVALID: motor_encoder_units_e = 2147483647;
#[doc = " Indicates the units used by the motor encoders."]
pub type motor_encoder_units_e = ::std::os::raw::c_uint;
#[doc = " Indicates the units used by the motor encoders."]
pub use self::motor_encoder_units_e as motor_encoder_units_e_t;
pub const motor_gearset_e_E_MOTOR_GEARSET_36: motor_gearset_e = 0;
pub const motor_gearset_e_E_MOTOR_GEAR_RED: motor_gearset_e = 0;
pub const motor_gearset_e_E_MOTOR_GEAR_100: motor_gearset_e = 0;
pub const motor_gearset_e_E_MOTOR_GEARSET_18: motor_gearset_e = 1;
pub const motor_gearset_e_E_MOTOR_GEAR_GREEN: motor_gearset_e = 1;
pub const motor_gearset_e_E_MOTOR_GEAR_200: motor_gearset_e = 1;
pub const motor_gearset_e_E_MOTOR_GEARSET_06: motor_gearset_e = 2;
pub const motor_gearset_e_E_MOTOR_GEAR_BLUE: motor_gearset_e = 2;
pub const motor_gearset_e_E_MOTOR_GEAR_600: motor_gearset_e = 2;
pub const motor_gearset_e_E_MOTOR_GEARSET_INVALID: motor_gearset_e = 2147483647;
#[doc = " Indicates the current internal gear ratio of a motor."]
pub type motor_gearset_e = ::std::os::raw::c_uint;
#[doc = " Indicates the current internal gear ratio of a motor."]
pub use self::motor_gearset_e as motor_gearset_e_t;
#[doc = " Holds the information about a Motor's position or velocity PID controls."]
#[doc = ""]
#[doc = " These values are in 4.4 format, meaning that a value of 0x20 represents 2.0,"]
#[doc = " 0x21 represents 2.0625, 0x22 represents 2.125, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct motor_pid_full_s {
    pub kf: u8,
    pub kp: u8,
    pub ki: u8,
    pub kd: u8,
    pub filter: u8,
    pub limit: u16,
    pub threshold: u8,
    pub loopspeed: u8,
}
#[test]
fn bindgen_test_layout_motor_pid_full_s() {
    const UNINIT: ::std::mem::MaybeUninit<motor_pid_full_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<motor_pid_full_s>(),
        10usize,
        concat!("Size of: ", stringify!(motor_pid_full_s))
    );
    assert_eq!(
        ::std::mem::align_of::<motor_pid_full_s>(),
        2usize,
        concat!("Alignment of ", stringify!(motor_pid_full_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(kf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kp) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(kp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ki) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(ki)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kd) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(kd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loopspeed) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(loopspeed)
        )
    );
}
#[doc = " Holds the information about a Motor's position or velocity PID controls."]
#[doc = ""]
#[doc = " These values are in 4.4 format, meaning that a value of 0x20 represents 2.0,"]
#[doc = " 0x21 represents 2.0625, 0x22 represents 2.125, etc."]
pub type motor_pid_full_s_t = motor_pid_full_s;
#[doc = " Holds just the constants for a Motor's position or velocity PID controls."]
#[doc = ""]
#[doc = " These values are in 4.4 format, meaning that a value of 0x20 represents 2.0,"]
#[doc = " 0x21 represents 2.0625, 0x22 represents 2.125, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct motor_pid_s {
    pub kf: u8,
    pub kp: u8,
    pub ki: u8,
    pub kd: u8,
}
#[test]
fn bindgen_test_layout_motor_pid_s() {
    const UNINIT: ::std::mem::MaybeUninit<motor_pid_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<motor_pid_s>(),
        4usize,
        concat!("Size of: ", stringify!(motor_pid_s))
    );
    assert_eq!(
        ::std::mem::align_of::<motor_pid_s>(),
        1usize,
        concat!("Alignment of ", stringify!(motor_pid_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_s),
            "::",
            stringify!(kf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kp) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_s),
            "::",
            stringify!(kp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ki) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_s),
            "::",
            stringify!(ki)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kd) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_s),
            "::",
            stringify!(kd)
        )
    );
}
#[doc = " Holds just the constants for a Motor's position or velocity PID controls."]
#[doc = ""]
#[doc = " These values are in 4.4 format, meaning that a value of 0x20 represents 2.0,"]
#[doc = " 0x21 represents 2.0625, 0x22 represents 2.125, etc."]
pub type motor_pid_s_t = motor_pid_s;
extern "C" {
    #[doc = " Sets the position for the motor in its encoder units."]
    #[doc = ""]
    #[doc = " This will be the future reference point for the motor's \"absolute\" position."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param position"]
    #[doc = "        The new reference position in its encoder units"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_set_zero_position(port: u8, position: f64) -> i32;
}
extern "C" {
    #[doc = " Sets the \"absolute\" zero position of the motor to its current position."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_tare_position(port: u8) -> i32;
}
extern "C" {
    #[doc = " Sets one of motor_brake_mode_e_t to the motor."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param mode"]
    #[doc = "        The motor_brake_mode_e_t to set for the motor"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_set_brake_mode(port: u8, mode: motor_brake_mode_e_t) -> i32;
}
extern "C" {
    #[doc = " Sets the current limit for the motor in mA."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param limit"]
    #[doc = "        The new current limit in mA"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_set_current_limit(port: u8, limit: i32) -> i32;
}
extern "C" {
    #[doc = " Sets one of motor_encoder_units_e_t for the motor encoder."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param units"]
    #[doc = "        The new motor encoder units"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_set_encoder_units(port: u8, units: motor_encoder_units_e_t) -> i32;
}
extern "C" {
    #[doc = " Sets one of motor_gearset_e_t for the motor."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param gearset"]
    #[doc = "        The new motor gearset"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_set_gearing(port: u8, gearset: motor_gearset_e_t) -> i32;
}
extern "C" {
    #[doc = " Takes in floating point values and returns a properly formatted pid struct."]
    #[doc = " The motor_pid_s_t struct is in 4.4 format, i.e. 0x20 is 2.0, 0x21 is 2.0625,"]
    #[doc = " etc."]
    #[doc = " This function will convert the floating point values to the nearest 4.4"]
    #[doc = " value."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param kf"]
    #[doc = "        The feedforward constant"]
    #[doc = " \\param kp"]
    #[doc = "        The proportional constant"]
    #[doc = " \\param ki"]
    #[doc = "        The integral constant"]
    #[doc = " \\param kd"]
    #[doc = "        The derivative constant"]
    #[doc = ""]
    #[doc = " \\return A motor_pid_s_t struct formatted properly in 4.4."]
    pub fn motor_convert_pid(kf: f64, kp: f64, ki: f64, kd: f64) -> motor_pid_s_t;
}
extern "C" {
    #[doc = " Takes in floating point values and returns a properly formatted pid struct."]
    #[doc = " The motor_pid_s_t struct is in 4.4 format, i.e. 0x20 is 2.0, 0x21 is 2.0625,"]
    #[doc = " etc."]
    #[doc = " This function will convert the floating point values to the nearest 4.4"]
    #[doc = " value."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param kf"]
    #[doc = "        The feedforward constant"]
    #[doc = " \\param kp"]
    #[doc = "        The proportional constant"]
    #[doc = " \\param ki"]
    #[doc = "        The integral constant"]
    #[doc = " \\param kd"]
    #[doc = "        The derivative constant"]
    #[doc = " \\param filter"]
    #[doc = "        A constant used for filtering the profile acceleration"]
    #[doc = " \\param limit"]
    #[doc = "        The integral limit"]
    #[doc = " \\param threshold"]
    #[doc = "        The threshold for determining if a position movement has reached its"]
    #[doc = "        goal. This has no effect for velocity PID calculations."]
    #[doc = " \\param loopspeed"]
    #[doc = "        The rate at which the PID computation is run in ms"]
    #[doc = ""]
    #[doc = " \\return A motor_pid_s_t struct formatted properly in 4.4."]
    pub fn motor_convert_pid_full(
        kf: f64,
        kp: f64,
        ki: f64,
        kd: f64,
        filter: f64,
        limit: f64,
        threshold: f64,
        loopspeed: f64,
    ) -> motor_pid_full_s_t;
}
extern "C" {
    #[doc = " Sets one of motor_pid_s_t for the motor. This intended to just modify the"]
    #[doc = " main PID constants."]
    #[doc = ""]
    #[doc = " Only non-zero values of the struct will change the existing motor constants."]
    #[doc = ""]
    #[doc = " \\note This feature is in beta, it is advised to use caution when modifying"]
    #[doc = " the PID values. The motor could be damaged by particularly large constants."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param pid"]
    #[doc = "        The new motor PID constants"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_set_pos_pid(port: u8, pid: motor_pid_s_t) -> i32;
}
extern "C" {
    #[doc = " Sets one of motor_pid_full_s_t for the motor."]
    #[doc = ""]
    #[doc = " Only non-zero values of the struct will change the existing motor constants."]
    #[doc = ""]
    #[doc = " \\note This feature is in beta, it is advised to use caution when modifying"]
    #[doc = " the PID values. The motor could be damaged by particularly large constants."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param pid"]
    #[doc = "        The new motor PID constants"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_set_pos_pid_full(port: u8, pid: motor_pid_full_s_t) -> i32;
}
extern "C" {
    #[doc = " Sets one of motor_pid_s_t for the motor. This intended to just modify the"]
    #[doc = " main PID constants."]
    #[doc = ""]
    #[doc = " Only non-zero values of the struct will change the existing motor constants."]
    #[doc = ""]
    #[doc = " \\note This feature is in beta, it is advised to use caution when modifying"]
    #[doc = " the PID values. The motor could be damaged by particularly large constants."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param pid"]
    #[doc = "        The new motor PID constants"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_set_vel_pid(port: u8, pid: motor_pid_s_t) -> i32;
}
extern "C" {
    #[doc = " Sets one of motor_pid_full_s_t for the motor."]
    #[doc = ""]
    #[doc = " Only non-zero values of the struct will change the existing motor constants."]
    #[doc = ""]
    #[doc = " \\note This feature is in beta, it is advised to use caution when modifying"]
    #[doc = " the PID values. The motor could be damaged by particularly large constants."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param pid"]
    #[doc = "        The new motor PID constants"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_set_vel_pid_full(port: u8, pid: motor_pid_full_s_t) -> i32;
}
extern "C" {
    #[doc = " Sets the reverse flag for the motor."]
    #[doc = ""]
    #[doc = " This will invert its movements and the values returned for its position."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param reverse"]
    #[doc = "        True reverses the motor, false is default"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_set_reversed(port: u8, reverse: bool) -> i32;
}
extern "C" {
    #[doc = " Sets the voltage limit for the motor in Volts."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param limit"]
    #[doc = "        The new voltage limit in Volts"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn motor_set_voltage_limit(port: u8, limit: i32) -> i32;
}
extern "C" {
    #[doc = " Gets the brake mode that was set for the motor."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return One of motor_brake_mode_e_t, according to what was set for the motor,"]
    #[doc = " or E_MOTOR_BRAKE_INVALID if the operation failed, setting errno."]
    pub fn motor_get_brake_mode(port: u8) -> motor_brake_mode_e_t;
}
extern "C" {
    #[doc = " Gets the current limit for the motor in mA."]
    #[doc = ""]
    #[doc = " The default value is 2500 mA."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The motor's current limit in mA or PROS_ERR if the operation failed,"]
    #[doc = " setting errno."]
    pub fn motor_get_current_limit(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the encoder units that were set for the motor."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return One of motor_encoder_units_e_t according to what is set for the motor"]
    #[doc = " or E_MOTOR_ENCODER_INVALID if the operation failed."]
    pub fn motor_get_encoder_units(port: u8) -> motor_encoder_units_e_t;
}
extern "C" {
    #[doc = " Gets the gearset that was set for the motor."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return One of motor_gearset_e_t according to what is set for the motor,"]
    #[doc = " or E_GEARSET_INVALID if the operation failed."]
    pub fn motor_get_gearing(port: u8) -> motor_gearset_e_t;
}
extern "C" {
    #[doc = " Gets the position PID that was set for the motor. This function will return"]
    #[doc = " zero for all of the parameters if the motor_set_pos_pid() or"]
    #[doc = " motor_set_pos_pid_full() functions have not been used."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " Additionally, in an error state all values of the returned struct are set"]
    #[doc = " to their negative maximum values."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return A motor_pid_full_s_t containing the position PID constants last set"]
    #[doc = " to the given motor"]
    pub fn motor_get_pos_pid(port: u8) -> motor_pid_full_s_t;
}
extern "C" {
    #[doc = " Gets the velocity PID that was set for the motor. This function will return"]
    #[doc = " zero for all of the parameters if the motor_set_vel_pid() or"]
    #[doc = " motor_set_vel_pid_full() functions have not been used."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " Additionally, in an error state all values of the returned struct are set"]
    #[doc = " to their negative maximum values."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return A motor_pid_full_s_t containing the velocity PID constants last set"]
    #[doc = " to the given motor"]
    pub fn motor_get_vel_pid(port: u8) -> motor_pid_full_s_t;
}
extern "C" {
    #[doc = " Gets the operation direction of the motor as set by the user."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return 1 if the motor has been reversed and 0 if the motor was not reversed,"]
    #[doc = " or PROS_ERR if the operation failed, setting errno."]
    pub fn motor_is_reversed(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the voltage limit set by the user."]
    #[doc = ""]
    #[doc = " Default value is 0V, which means that there is no software limitation imposed"]
    #[doc = " on the voltage."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a motor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The motor's voltage limit in V or PROS_ERR if the operation failed,"]
    #[doc = " setting errno."]
    pub fn motor_get_voltage_limit(port: u8) -> i32;
}
pub const optical_direction_e_NO_GESTURE: optical_direction_e = 0;
pub const optical_direction_e_UP: optical_direction_e = 1;
pub const optical_direction_e_DOWN: optical_direction_e = 2;
pub const optical_direction_e_RIGHT: optical_direction_e = 3;
pub const optical_direction_e_LEFT: optical_direction_e = 4;
pub const optical_direction_e_ERROR: optical_direction_e = 2147483647;
pub type optical_direction_e = ::std::os::raw::c_uint;
pub use self::optical_direction_e as optical_direction_e_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct optical_rgb_s {
    pub red: f64,
    pub green: f64,
    pub blue: f64,
    pub brightness: f64,
}
#[test]
fn bindgen_test_layout_optical_rgb_s() {
    const UNINIT: ::std::mem::MaybeUninit<optical_rgb_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<optical_rgb_s>(),
        32usize,
        concat!("Size of: ", stringify!(optical_rgb_s))
    );
    assert_eq!(
        ::std::mem::align_of::<optical_rgb_s>(),
        8usize,
        concat!("Alignment of ", stringify!(optical_rgb_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_rgb_s),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_rgb_s),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_rgb_s),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).brightness) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_rgb_s),
            "::",
            stringify!(brightness)
        )
    );
}
pub type optical_rgb_s_t = optical_rgb_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct optical_raw_s {
    pub clear: u32,
    pub red: u32,
    pub green: u32,
    pub blue: u32,
}
#[test]
fn bindgen_test_layout_optical_raw_s() {
    const UNINIT: ::std::mem::MaybeUninit<optical_raw_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<optical_raw_s>(),
        16usize,
        concat!("Size of: ", stringify!(optical_raw_s))
    );
    assert_eq!(
        ::std::mem::align_of::<optical_raw_s>(),
        4usize,
        concat!("Alignment of ", stringify!(optical_raw_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_raw_s),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_raw_s),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_raw_s),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_raw_s),
            "::",
            stringify!(blue)
        )
    );
}
pub type optical_raw_s_t = optical_raw_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct optical_gesture_s {
    pub udata: u8,
    pub ddata: u8,
    pub ldata: u8,
    pub rdata: u8,
    pub type_: u8,
    pub pad: u8,
    pub count: u16,
    pub time: u32,
}
#[test]
fn bindgen_test_layout_optical_gesture_s() {
    const UNINIT: ::std::mem::MaybeUninit<optical_gesture_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<optical_gesture_s>(),
        12usize,
        concat!("Size of: ", stringify!(optical_gesture_s))
    );
    assert_eq!(
        ::std::mem::align_of::<optical_gesture_s>(),
        4usize,
        concat!("Alignment of ", stringify!(optical_gesture_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_gesture_s),
            "::",
            stringify!(udata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ddata) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_gesture_s),
            "::",
            stringify!(ddata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ldata) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_gesture_s),
            "::",
            stringify!(ldata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdata) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_gesture_s),
            "::",
            stringify!(rdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_gesture_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_gesture_s),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_gesture_s),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(optical_gesture_s),
            "::",
            stringify!(time)
        )
    );
}
pub type optical_gesture_s_t = optical_gesture_s;
extern "C" {
    #[doc = " Get the detected color hue"]
    #[doc = ""]
    #[doc = " This is not available if gestures are being detected. Hue has a"]
    #[doc = " range of 0 to 359.999"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Optical Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Optical Sensor port number from 1-21"]
    #[doc = " \\return hue value if the operation was successful or PROS_ERR_F if the operation"]
    #[doc = " failed, setting errno."]
    pub fn optical_get_hue(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get the detected color saturation"]
    #[doc = ""]
    #[doc = " This is not available if gestures are being detected. Saturation has a"]
    #[doc = " range of 0 to 1.0"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Optical Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Optical Sensor port number from 1-21"]
    #[doc = " \\return saturation value if the operation was successful or PROS_ERR_F if"]
    #[doc = " the operation failed, setting errno."]
    pub fn optical_get_saturation(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get the detected color brightness"]
    #[doc = ""]
    #[doc = " This is not available if gestures are being detected. Brightness has a"]
    #[doc = " range of 0 to 1.0"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Optical Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Optical Sensor port number from 1-21"]
    #[doc = " \\return brightness value if the operation was successful or PROS_ERR_F if"]
    #[doc = " the operation failed, setting errno."]
    pub fn optical_get_brightness(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get the detected proximity value"]
    #[doc = ""]
    #[doc = " This is not available if gestures are being detected. proximity has"]
    #[doc = " a range of 0 to 255."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Optical Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Optical Sensor port number from 1-21"]
    #[doc = " \\return poximity value if the operation was successful or PROS_ERR if"]
    #[doc = " the operation failed, setting errno."]
    pub fn optical_get_proximity(port: u8) -> i32;
}
extern "C" {
    #[doc = " Set the pwm value of the White LED"]
    #[doc = ""]
    #[doc = " value that ranges from 0 to 100"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Optical Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Optical Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation is successful or PROS_ERR if the operation failed,"]
    #[doc = " setting errno."]
    pub fn optical_set_led_pwm(port: u8, value: u8) -> i32;
}
extern "C" {
    #[doc = " Get the pwm value of the White LED"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Optical Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Optical Sensor port number from 1-21"]
    #[doc = " \\return LED pwm value that ranges from 0 to 100 if the operation was"]
    #[doc = " successful or PROS_ERR if the operation failed, setting errno."]
    pub fn optical_get_led_pwm(port: u8) -> i32;
}
extern "C" {
    #[doc = " Get the processed RGBC data from the sensor"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Optical Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Optical Sensor port number from 1-21"]
    #[doc = " \\return rgb value if the operation was successful or an optical_rgb_s_t with"]
    #[doc = " all fields set to PROS_ERR if the operation failed, setting errno."]
    pub fn optical_get_rgb(port: u8) -> optical_rgb_s_t;
}
extern "C" {
    #[doc = " Get the raw, unprocessed RGBC data from the sensor"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Optical Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Optical Sensor port number from 1-21"]
    #[doc = " \\return raw rgb value if the operation was successful or an optical_raw_s_t"]
    #[doc = " with all fields set to PROS_ERR if the operation failed, setting errno."]
    pub fn optical_get_raw(port: u8) -> optical_raw_s_t;
}
extern "C" {
    #[doc = " Get the most recent gesture data from the sensor"]
    #[doc = ""]
    #[doc = " Gestures will be cleared after 500mS"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Optical Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Optical Sensor port number from 1-21"]
    #[doc = " \\return gesture value if the operation was successful or PROS_ERR if"]
    #[doc = " the operation failed, setting errno."]
    pub fn optical_get_gesture(port: u8) -> optical_direction_e_t;
}
extern "C" {
    #[doc = " Get the most recent raw gesture data from the sensor"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Optical Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Optical Sensor port number from 1-21"]
    #[doc = " \\return gesture value if the operation was successful or an optical_gesture_s_t"]
    #[doc = " with all fields set to PROS_ERR if the operation failed, setting errno."]
    pub fn optical_get_gesture_raw(port: u8) -> optical_gesture_s_t;
}
extern "C" {
    #[doc = " Enable gesture detection on the sensor"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Optical Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Optical Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation is successful or PROS_ERR if the operation failed,"]
    #[doc = " setting errno."]
    pub fn optical_enable_gesture(port: u8) -> i32;
}
extern "C" {
    #[doc = " Disable gesture detection on the sensor"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Optical Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Optical Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation is successful or PROS_ERR if the operation failed,"]
    #[doc = " setting errno."]
    pub fn optical_disable_gesture(port: u8) -> i32;
}
pub type task_t = *mut ::std::os::raw::c_void;
pub type task_fn_t = ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub const task_state_e_t_E_TASK_STATE_RUNNING: task_state_e_t = 0;
pub const task_state_e_t_E_TASK_STATE_READY: task_state_e_t = 1;
pub const task_state_e_t_E_TASK_STATE_BLOCKED: task_state_e_t = 2;
pub const task_state_e_t_E_TASK_STATE_SUSPENDED: task_state_e_t = 3;
pub const task_state_e_t_E_TASK_STATE_DELETED: task_state_e_t = 4;
pub const task_state_e_t_E_TASK_STATE_INVALID: task_state_e_t = 5;
pub type task_state_e_t = ::std::os::raw::c_uint;
pub const notify_action_e_t_E_NOTIFY_ACTION_NONE: notify_action_e_t = 0;
pub const notify_action_e_t_E_NOTIFY_ACTION_BITS: notify_action_e_t = 1;
pub const notify_action_e_t_E_NOTIFY_ACTION_INCR: notify_action_e_t = 2;
pub const notify_action_e_t_E_NOTIFY_ACTION_OWRITE: notify_action_e_t = 3;
pub const notify_action_e_t_E_NOTIFY_ACTION_NO_OWRITE: notify_action_e_t = 4;
pub type notify_action_e_t = ::std::os::raw::c_uint;
pub type mutex_t = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " Gets the number of milliseconds since PROS initialized."]
    #[doc = ""]
    #[doc = " \\return The number of milliseconds since PROS initialized"]
    pub fn millis() -> u32;
}
extern "C" {
    #[doc = " Gets the number of microseconds since PROS initialized,"]
    #[doc = ""]
    #[doc = " \\return The number of microseconds since PROS initialized"]
    pub fn micros() -> u64;
}
extern "C" {
    #[doc = " Creates a new task and add it to the list of tasks that are ready to run."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENOMEM - The stack cannot be used as the TCB was not created."]
    #[doc = ""]
    #[doc = " \\param function"]
    #[doc = "        Pointer to the task entry function"]
    #[doc = " \\param parameters"]
    #[doc = "        Pointer to memory that will be used as a parameter for the task being"]
    #[doc = "        created. This memory should not typically come from stack, but rather"]
    #[doc = "        from dynamically (i.e., malloc'd) or statically allocated memory."]
    #[doc = " \\param prio"]
    #[doc = "        The priority at which the task should run."]
    #[doc = "        TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used."]
    #[doc = " \\param stack_depth"]
    #[doc = "        The number of words (i.e. 4 * stack_depth) available on the task's"]
    #[doc = "        stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct."]
    #[doc = " \\param name"]
    #[doc = "        A descriptive name for the task.  This is mainly used to facilitate"]
    #[doc = "        debugging. The name may be up to 32 characters long."]
    #[doc = ""]
    #[doc = " \\return A handle by which the newly created task can be referenced. If an"]
    #[doc = " error occurred, NULL will be returned and errno can be checked for hints as"]
    #[doc = " to why task_create failed."]
    pub fn task_create(
        function: task_fn_t,
        parameters: *mut ::std::os::raw::c_void,
        prio: u32,
        stack_depth: u16,
        name: *const ::std::os::raw::c_char,
    ) -> task_t;
}
extern "C" {
    #[doc = " Removes a task from the RTOS real time kernel's management. The task being"]
    #[doc = " deleted will be removed from all ready, blocked, suspended and event lists."]
    #[doc = ""]
    #[doc = " Memory dynamically allocated by the task is not automatically freed, and"]
    #[doc = " should be freed before the task is deleted."]
    #[doc = ""]
    #[doc = " \\param task"]
    #[doc = "        The handle of the task to be deleted.  Passing NULL will cause the"]
    #[doc = "        calling task to be deleted."]
    pub fn task_delete(task: task_t);
}
extern "C" {
    #[doc = " Delays a task for a given number of milliseconds."]
    #[doc = ""]
    #[doc = " This is not the best method to have a task execute code at predefined"]
    #[doc = " intervals, as the delay time is measured from when the delay is requested."]
    #[doc = " To delay cyclically, use task_delay_until()."]
    #[doc = ""]
    #[doc = " \\param milliseconds"]
    #[doc = "        The number of milliseconds to wait (1000 milliseconds per second)"]
    pub fn task_delay(milliseconds: u32);
}
extern "C" {
    pub fn delay(milliseconds: u32);
}
extern "C" {
    #[doc = " Delays a task until a specified time.  This function can be used by periodic"]
    #[doc = " tasks to ensure a constant execution frequency."]
    #[doc = ""]
    #[doc = " The task will be woken up at the time *prev_time + delta, and *prev_time will"]
    #[doc = " be updated to reflect the time at which the task will unblock."]
    #[doc = ""]
    #[doc = " \\param prev_time"]
    #[doc = "        A pointer to the location storing the setpoint time. This should"]
    #[doc = "        typically be initialized to the return value of millis()."]
    #[doc = " \\param delta"]
    #[doc = "        The number of milliseconds to wait (1000 milliseconds per second)"]
    pub fn task_delay_until(prev_time: *mut u32, delta: u32);
}
extern "C" {
    #[doc = " Gets the priority of the specified task."]
    #[doc = ""]
    #[doc = " \\param task"]
    #[doc = "        The task to check"]
    #[doc = ""]
    #[doc = " \\return The priority of the task"]
    pub fn task_get_priority(task: task_t) -> u32;
}
extern "C" {
    #[doc = " Sets the priority of the specified task."]
    #[doc = ""]
    #[doc = " If the specified task's state is available to be scheduled (e.g. not blocked)"]
    #[doc = " and new priority is higher than the currently running task, a context switch"]
    #[doc = " may occur."]
    #[doc = ""]
    #[doc = " \\param task"]
    #[doc = "        The task to set"]
    #[doc = " \\param prio"]
    #[doc = "        The new priority of the task"]
    pub fn task_set_priority(task: task_t, prio: u32);
}
extern "C" {
    #[doc = " Gets the state of the specified task."]
    #[doc = ""]
    #[doc = " \\param task"]
    #[doc = "        The task to check"]
    #[doc = ""]
    #[doc = " \\return The state of the task"]
    pub fn task_get_state(task: task_t) -> task_state_e_t;
}
extern "C" {
    #[doc = " Suspends the specified task, making it ineligible to be scheduled."]
    #[doc = ""]
    #[doc = " \\param task"]
    #[doc = "        The task to suspend"]
    pub fn task_suspend(task: task_t);
}
extern "C" {
    #[doc = " Resumes the specified task, making it eligible to be scheduled."]
    #[doc = ""]
    #[doc = " \\param task"]
    #[doc = "        The task to resume"]
    pub fn task_resume(task: task_t);
}
extern "C" {
    #[doc = " Gets the number of tasks the kernel is currently managing, including all"]
    #[doc = " ready, blocked, or suspended tasks. A task that has been deleted, but not yet"]
    #[doc = " reaped by the idle task will also be included in the count. Tasks recently"]
    #[doc = " created may take one context switch to be counted."]
    #[doc = ""]
    #[doc = " \\return The number of tasks that are currently being managed by the kernel."]
    pub fn task_get_count() -> u32;
}
extern "C" {
    #[doc = " Gets the name of the specified task."]
    #[doc = ""]
    #[doc = " \\param task"]
    #[doc = "        The task to check"]
    #[doc = ""]
    #[doc = " \\return A pointer to the name of the task"]
    pub fn task_get_name(task: task_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets a task handle from the specified name"]
    #[doc = ""]
    #[doc = " The operation takes a relatively long time and should be used sparingly."]
    #[doc = ""]
    #[doc = " \\param name"]
    #[doc = "        The name to query"]
    #[doc = ""]
    #[doc = " \\return A task handle with a matching name, or NULL if none were found."]
    pub fn task_get_by_name(name: *const ::std::os::raw::c_char) -> task_t;
}
extern "C" {
    #[doc = " Get the currently running task handle. This could be useful if a task"]
    #[doc = " wants to tell another task about itself."]
    #[doc = ""]
    #[doc = " \\return The currently running task handle."]
    pub fn task_get_current() -> task_t;
}
extern "C" {
    #[doc = " Sends a simple notification to task and increments the notification counter."]
    #[doc = ""]
    #[doc = " See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for"]
    #[doc = " details."]
    #[doc = ""]
    #[doc = " \\param task"]
    #[doc = "        The task to notify"]
    #[doc = ""]
    #[doc = " \\return Always returns true."]
    pub fn task_notify(task: task_t) -> u32;
}
extern "C" {
    #[doc = " Utilizes task notifications to wait until specified task is complete and deleted,"]
    #[doc = " then continues to execute the program. Analogous to std::thread::join in C++."]
    #[doc = ""]
    #[doc = " See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for"]
    #[doc = " details."]
    #[doc = ""]
    #[doc = " \\param task"]
    #[doc = "        The task to wait on."]
    #[doc = ""]
    #[doc = " \\return void"]
    pub fn task_join(task: task_t);
}
extern "C" {
    #[doc = " Sends a notification to a task, optionally performing some action. Will also"]
    #[doc = " retrieve the value of the notification in the target task before modifying"]
    #[doc = " the notification value."]
    #[doc = ""]
    #[doc = " See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for"]
    #[doc = " details."]
    #[doc = ""]
    #[doc = " \\param task"]
    #[doc = "        The task to notify"]
    #[doc = " \\param value"]
    #[doc = "        The value used in performing the action"]
    #[doc = " \\param action"]
    #[doc = "        An action to optionally perform on the receiving task's notification"]
    #[doc = "        value"]
    #[doc = " \\param prev_value"]
    #[doc = "        A pointer to store the previous value of the target task's"]
    #[doc = "        notification, may be NULL"]
    #[doc = ""]
    #[doc = " \\return Dependent on the notification action."]
    #[doc = " For NOTIFY_ACTION_NO_WRITE: return 0 if the value could be written without"]
    #[doc = " needing to overwrite, 1 otherwise."]
    #[doc = " For all other NOTIFY_ACTION values: always return 0"]
    pub fn task_notify_ext(
        task: task_t,
        value: u32,
        action: notify_action_e_t,
        prev_value: *mut u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Waits for a notification to be nonzero."]
    #[doc = ""]
    #[doc = " See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for"]
    #[doc = " details."]
    #[doc = ""]
    #[doc = " \\param clear_on_exit"]
    #[doc = "        If true (1), then the notification value is cleared."]
    #[doc = "        If false (0), then the notification value is decremented."]
    #[doc = " \\param timeout"]
    #[doc = "        Specifies the amount of time to be spent waiting for a notification"]
    #[doc = "        to occur."]
    #[doc = ""]
    #[doc = " \\return The value of the task's notification value before it is decremented"]
    #[doc = " or cleared"]
    pub fn task_notify_take(clear_on_exit: bool, timeout: u32) -> u32;
}
extern "C" {
    #[doc = " Clears the notification for a task."]
    #[doc = ""]
    #[doc = " See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for"]
    #[doc = " details."]
    #[doc = ""]
    #[doc = " \\param task"]
    #[doc = "        The task to clear"]
    #[doc = ""]
    #[doc = " \\return False if there was not a notification waiting, true if there was"]
    pub fn task_notify_clear(task: task_t) -> bool;
}
extern "C" {
    #[doc = " Creates a mutex."]
    #[doc = ""]
    #[doc = " See https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes"]
    #[doc = " for details."]
    #[doc = ""]
    #[doc = " \\return A handle to a newly created mutex. If an error occurred, NULL will be"]
    #[doc = " returned and errno can be checked for hints as to why mutex_create failed."]
    pub fn mutex_create() -> mutex_t;
}
extern "C" {
    #[doc = " Takes and locks a mutex, waiting for up to a certain number of milliseconds"]
    #[doc = " before timing out."]
    #[doc = ""]
    #[doc = " See https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes"]
    #[doc = " for details."]
    #[doc = ""]
    #[doc = " \\param mutex"]
    #[doc = "        Mutex to attempt to lock."]
    #[doc = " \\param timeout"]
    #[doc = "        Time to wait before the mutex becomes available. A timeout of 0 can"]
    #[doc = "        be used to poll the mutex. TIMEOUT_MAX can be used to block"]
    #[doc = "        indefinitely."]
    #[doc = ""]
    #[doc = " \\return True if the mutex was successfully taken, false otherwise. If false"]
    #[doc = " is returned, then errno is set with a hint about why the the mutex"]
    #[doc = " couldn't be taken."]
    pub fn mutex_take(mutex: mutex_t, timeout: u32) -> bool;
}
extern "C" {
    #[doc = " Unlocks a mutex."]
    #[doc = ""]
    #[doc = " See https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes"]
    #[doc = " for details."]
    #[doc = ""]
    #[doc = " \\param mutex"]
    #[doc = "        Mutex to unlock."]
    #[doc = ""]
    #[doc = " \\return True if the mutex was successfully returned, false otherwise. If"]
    #[doc = " false is returned, then errno is set with a hint about why the mutex"]
    #[doc = " couldn't be returned."]
    pub fn mutex_give(mutex: mutex_t) -> bool;
}
extern "C" {
    #[doc = " Deletes a mutex"]
    #[doc = ""]
    #[doc = " \\param mutex"]
    #[doc = "        Mutex to unlock."]
    pub fn mutex_delete(mutex: mutex_t);
}
extern "C" {
    #[doc = " Reset Rotation Sensor"]
    #[doc = ""]
    #[doc = " Reset the current absolute position to be the same as the"]
    #[doc = " Rotation Sensor angle."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Rotation Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Rotation Sensor port number from 1-21"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn rotation_reset(port: u8) -> i32;
}
extern "C" {
    #[doc = " Set the Rotation Sensor's refresh interval in milliseconds."]
    #[doc = ""]
    #[doc = " The rate may be specified in increments of 5ms, and will be rounded down to"]
    #[doc = " the nearest increment. The minimum allowable refresh rate is 5ms. The default"]
    #[doc = " rate is 10ms."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Rotation Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 Rotation Sensor port number from 1-21"]
    #[doc = " \\param rate The data refresh interval in milliseconds"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn rotation_set_data_rate(port: u8, rate: u32) -> i32;
}
extern "C" {
    #[doc = " Set the Rotation Sensor position reading to a desired rotation value"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Rotation Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "\t\t  The V5 Rotation Sensor port number from 1-21"]
    #[doc = " \\param position"]
    #[doc = " \t\t  The position in terms of ticks"]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn rotation_set_position(port: u8, position: u32) -> i32;
}
extern "C" {
    #[doc = " Reset the Rotation Sensor position to 0"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Rotation Sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "\t\t  The V5 Rotation Sensor port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn rotation_reset_position(port: u8) -> i32;
}
extern "C" {
    #[doc = " Get the Rotation Sensor's current position in centidegrees"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Rotation Sensor"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Rotation Sensor port number from 1-21"]
    #[doc = " \\return The position value or PROS_ERR_F if the operation failed, setting"]
    #[doc = " errno."]
    pub fn rotation_get_position(port: u8) -> i32;
}
extern "C" {
    #[doc = " Get the Rotation Sensor's current velocity in centidegrees per second"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Rotation Sensor"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Rotation Sensor port number from 1-21"]
    #[doc = " \\return The velocity value or PROS_ERR_F if the operation failed, setting"]
    #[doc = " errno."]
    pub fn rotation_get_velocity(port: u8) -> i32;
}
extern "C" {
    #[doc = " Get the Rotation Sensor's current angle in centidegrees (0-36000)"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Rotation Sensor"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Rotation Sensor port number from 1-21"]
    #[doc = " \\return The angle value (0-36000) or PROS_ERR_F if the operation failed, setting"]
    #[doc = " errno."]
    pub fn rotation_get_angle(port: u8) -> i32;
}
extern "C" {
    #[doc = " Set the Rotation Sensor's direction reversed flag"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Rotation Sensor"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Rotation Sensor port number from 1-21"]
    #[doc = " \\param  value"]
    #[doc = " \t\t\t\t Determines if the direction of the Rotation Sensor is reversed or not."]
    #[doc = ""]
    #[doc = " \\return 1 if operation succeeded or PROS_ERR if the operation failed, setting"]
    #[doc = " errno."]
    pub fn rotation_set_reversed(port: u8, value: bool) -> i32;
}
extern "C" {
    #[doc = " Reverse the Rotation Sensor's direction"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Rotation Sensor"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Rotation Sensor port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn rotation_reverse(port: u8) -> i32;
}
extern "C" {
    #[doc = " Initialize the Rotation Sensor with a reverse flag"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Rotation Sensor"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Rotation Sensor port number from 1-21"]
    #[doc = " \\param  reverse_flag"]
    #[doc = " \t\t\t\t Determines if the Rotation Sensor is reversed or not."]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn rotation_init_reverse(port: u8, reverse_flag: bool) -> i32;
}
extern "C" {
    #[doc = " Get the Rotation Sensor's reversed flag"]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as an Rotation Sensor"]
    #[doc = ""]
    #[doc = " \\param  port"]
    #[doc = " \t\t\t\t The V5 Rotation Sensor port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return Boolean value of if the Rotation Sensor's direction is reversed or not"]
    #[doc = " or PROS_ERR if the operation failed, setting errno."]
    pub fn rotation_get_reversed(port: u8) -> i32;
}
pub const vision_object_type_E_VISION_OBJECT_NORMAL: vision_object_type = 0;
pub const vision_object_type_E_VISION_OBJECT_COLOR_CODE: vision_object_type = 1;
pub const vision_object_type_E_VISION_OBJECT_LINE: vision_object_type = 2;
#[doc = " This enumeration defines the different types of objects"]
#[doc = " that can be detected by the Vision Sensor"]
pub type vision_object_type = ::std::os::raw::c_uint;
#[doc = " This enumeration defines the different types of objects"]
#[doc = " that can be detected by the Vision Sensor"]
pub use self::vision_object_type as vision_object_type_e_t;
#[doc = " This structure contains the parameters used by the Vision Sensor"]
#[doc = " to detect objects."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vision_signature {
    pub id: u8,
    pub _pad: [u8; 3usize],
    pub range: f32,
    pub u_min: i32,
    pub u_max: i32,
    pub u_mean: i32,
    pub v_min: i32,
    pub v_max: i32,
    pub v_mean: i32,
    pub rgb: u32,
    pub type_: u32,
}
#[test]
fn bindgen_test_layout_vision_signature() {
    const UNINIT: ::std::mem::MaybeUninit<vision_signature> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vision_signature>(),
        40usize,
        concat!("Size of: ", stringify!(vision_signature))
    );
    assert_eq!(
        ::std::mem::align_of::<vision_signature>(),
        1usize,
        concat!("Alignment of ", stringify!(vision_signature))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u_min) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(u_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u_max) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(u_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u_mean) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(u_mean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_min) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(v_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_max) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(v_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_mean) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(v_mean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgb) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(rgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " This structure contains the parameters used by the Vision Sensor"]
#[doc = " to detect objects."]
pub type vision_signature_s_t = vision_signature;
#[doc = " Color codes are just signatures with multiple IDs and a different type."]
pub type vision_color_code_t = u16;
#[doc = " This structure contains a descriptor of an object detected"]
#[doc = " by the Vision Sensor"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vision_object {
    pub signature: u16,
    pub type_: vision_object_type_e_t,
    pub left_coord: i16,
    pub top_coord: i16,
    pub width: i16,
    pub height: i16,
    pub angle: u16,
    pub x_middle_coord: i16,
    pub y_middle_coord: i16,
}
#[test]
fn bindgen_test_layout_vision_object() {
    const UNINIT: ::std::mem::MaybeUninit<vision_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vision_object>(),
        20usize,
        concat!("Size of: ", stringify!(vision_object))
    );
    assert_eq!(
        ::std::mem::align_of::<vision_object>(),
        1usize,
        concat!("Alignment of ", stringify!(vision_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left_coord) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(left_coord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top_coord) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(top_coord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).angle) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_middle_coord) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(x_middle_coord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_middle_coord) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(y_middle_coord)
        )
    );
}
#[doc = " This structure contains a descriptor of an object detected"]
#[doc = " by the Vision Sensor"]
pub type vision_object_s_t = vision_object;
pub const vision_zero_E_VISION_ZERO_TOPLEFT: vision_zero = 0;
pub const vision_zero_E_VISION_ZERO_CENTER: vision_zero = 1;
pub type vision_zero = ::std::os::raw::c_uint;
pub use self::vision_zero as vision_zero_e_t;
extern "C" {
    #[doc = " Clears the vision sensor LED color, reseting it back to its default behavior,"]
    #[doc = " displaying the most prominent object signature color."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn vision_clear_led(port: u8) -> i32;
}
extern "C" {
    #[doc = " Creates a signature from the vision sensor utility"]
    #[doc = ""]
    #[doc = " \\param id"]
    #[doc = "        The signature ID"]
    #[doc = " \\param u_min"]
    #[doc = "        Minimum value on U axis"]
    #[doc = " \\param u_max"]
    #[doc = "        Maximum value on U axis"]
    #[doc = " \\param u_mean"]
    #[doc = "        Mean value on U axis"]
    #[doc = " \\param v_min"]
    #[doc = "        Minimum value on V axis"]
    #[doc = " \\param v_max"]
    #[doc = "        Maximum value on V axis"]
    #[doc = " \\param v_mean"]
    #[doc = "        Mean value on V axis"]
    #[doc = " \\param range"]
    #[doc = "        Scale factor"]
    #[doc = " \\param type"]
    #[doc = "        Signature type"]
    #[doc = ""]
    #[doc = " \\return A vision_signature_s_t that can be set using vision_set_signature"]
    pub fn vision_signature_from_utility(
        id: i32,
        u_min: i32,
        u_max: i32,
        u_mean: i32,
        v_min: i32,
        v_max: i32,
        v_mean: i32,
        range: f32,
        type_: i32,
    ) -> vision_signature_s_t;
}
extern "C" {
    #[doc = " Creates a color code that represents a combination of the given signature"]
    #[doc = " IDs. If fewer than 5 signatures are to be a part of the color code, pass 0"]
    #[doc = " for the additional function parameters."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " EINVAL - Fewer than two signatures have been provided or one of the"]
    #[doc = "          signatures is out of its [1-7] range (or 0 when omitted)."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param sig_id1"]
    #[doc = "        The first signature id [1-7] to add to the color code"]
    #[doc = " \\param sig_id2"]
    #[doc = "        The second signature id [1-7] to add to the color code"]
    #[doc = " \\param sig_id3"]
    #[doc = "        The third signature id [1-7] to add to the color code"]
    #[doc = " \\param sig_id4"]
    #[doc = "        The fourth signature id [1-7] to add to the color code"]
    #[doc = " \\param sig_id5"]
    #[doc = "        The fifth signature id [1-7] to add to the color code"]
    #[doc = ""]
    #[doc = " \\return A vision_color_code_t object containing the color code information."]
    pub fn vision_create_color_code(
        port: u8,
        sig_id1: u32,
        sig_id2: u32,
        sig_id3: u32,
        sig_id4: u32,
        sig_id5: u32,
    ) -> vision_color_code_t;
}
extern "C" {
    #[doc = " Gets the nth largest object according to size_id."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = " EDOM - size_id is greater than the number of available objects."]
    #[doc = " EHOSTDOWN - Reading the vision sensor failed for an unknown reason."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param size_id"]
    #[doc = "        The object to read from a list roughly ordered by object size"]
    #[doc = "        (0 is the largest item, 1 is the second largest, etc.)"]
    #[doc = ""]
    #[doc = " \\return The vision_object_s_t object corresponding to the given size id, or"]
    #[doc = " PROS_ERR if an error occurred."]
    pub fn vision_get_by_size(port: u8, size_id: u32) -> vision_object_s_t;
}
extern "C" {
    #[doc = " Gets the nth largest object of the given signature according to size_id."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = " EINVAL - sig_id is outside the range [1-8]"]
    #[doc = " EDOM - size_id is greater than the number of available objects."]
    #[doc = " EAGAIN - Reading the vision sensor failed for an unknown reason."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param size_id"]
    #[doc = "        The object to read from a list roughly ordered by object size"]
    #[doc = "        (0 is the largest item, 1 is the second largest, etc.)"]
    #[doc = " \\param signature"]
    #[doc = "        The signature ID [1-7] for which an object will be returned."]
    #[doc = ""]
    #[doc = " \\return The vision_object_s_t object corresponding to the given signature and"]
    #[doc = " size_id, or PROS_ERR if an error occurred."]
    pub fn vision_get_by_sig(port: u8, size_id: u32, sig_id: u32) -> vision_object_s_t;
}
extern "C" {
    #[doc = " Gets the nth largest object of the given color code according to size_id."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = " EAGAIN - Reading the vision sensor failed for an unknown reason."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param size_id"]
    #[doc = "        The object to read from a list roughly ordered by object size"]
    #[doc = "        (0 is the largest item, 1 is the second largest, etc.)"]
    #[doc = " \\param color_code"]
    #[doc = "        The vision_color_code_t for which an object will be returned"]
    #[doc = ""]
    #[doc = " \\return The vision_object_s_t object corresponding to the given color code"]
    #[doc = " and size_id, or PROS_ERR if an error occurred."]
    pub fn vision_get_by_code(
        port: u8,
        size_id: u32,
        color_code: vision_color_code_t,
    ) -> vision_object_s_t;
}
extern "C" {
    #[doc = " Gets the exposure parameter of the Vision Sensor. See"]
    #[doc = " https://pros.cs.purdue.edu/v5/tutorials/topical/vision.html#exposure-setting"]
    #[doc = " for more detials."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The current exposure setting from [0,150], PROS_ERR if an error"]
    #[doc = " occurred"]
    pub fn vision_get_exposure(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the number of objects currently detected by the Vision Sensor."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The number of objects detected on the specified vision sensor."]
    #[doc = " Returns PROS_ERR if the port was invalid or an error occurred."]
    pub fn vision_get_object_count(port: u8) -> i32;
}
extern "C" {
    #[doc = " Get the white balance parameter of the Vision Sensor."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = " \t\t    The V5 port number from 1-21"]
    #[doc = ""]
    #[doc = " \\return The current RGB white balance setting of the sensor"]
    pub fn vision_get_white_balance(port: u8) -> i32;
}
extern "C" {
    #[doc = " Prints the contents of the signature as an initializer list to the terminal."]
    #[doc = ""]
    #[doc = " \\param sig"]
    #[doc = "        The signature for which the contents will be printed"]
    #[doc = ""]
    #[doc = " \\return 1 if no errors occured, PROS_ERR otherwise"]
    pub fn vision_print_signature(sig: vision_signature_s_t) -> i32;
}
extern "C" {
    #[doc = " Reads up to object_count object descriptors into object_arr."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21), or"]
    #[doc = "          fewer than object_count number of objects were found."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = " EDOM - size_id is greater than the number of available objects."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param size_id"]
    #[doc = "        The object to read from a list roughly ordered by object size"]
    #[doc = "        (0 is the largest item, 1 is the second largest, etc.)"]
    #[doc = " \\param object_count"]
    #[doc = "        The number of objects to read"]
    #[doc = " \\param[out] object_arr"]
    #[doc = "             A pointer to copy the objects into"]
    #[doc = ""]
    #[doc = " \\return The number of object signatures copied. This number will be less than"]
    #[doc = " object_count if there are fewer objects detected by the vision sensor."]
    #[doc = " Returns PROS_ERR if the port was invalid, an error occurred, or fewer objects"]
    #[doc = " than size_id were found. All objects in object_arr that were not found are"]
    #[doc = " given VISION_OBJECT_ERR_SIG as their signature."]
    pub fn vision_read_by_size(
        port: u8,
        size_id: u32,
        object_count: u32,
        object_arr: *mut vision_object_s_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Reads up to object_count object descriptors into object_arr."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21), or"]
    #[doc = "          fewer than object_count number of objects were found."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = " EDOM - size_id is greater than the number of available objects."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param object_count"]
    #[doc = "        The number of objects to read"]
    #[doc = " \\param size_id"]
    #[doc = "        The object to read from a list roughly ordered by object size"]
    #[doc = "        (0 is the largest item, 1 is the second largest, etc.)"]
    #[doc = " \\param signature"]
    #[doc = "        The signature ID [1-7] for which objects will be returned."]
    #[doc = " \\param[out] object_arr"]
    #[doc = "             A pointer to copy the objects into"]
    #[doc = ""]
    #[doc = " \\return The number of object signatures copied. This number will be less than"]
    #[doc = " object_count if there are fewer objects detected by the vision sensor."]
    #[doc = " Returns PROS_ERR if the port was invalid, an error occurred, or fewer objects"]
    #[doc = " than size_id were found. All objects in object_arr that were not found are"]
    #[doc = " given VISION_OBJECT_ERR_SIG as their signature."]
    pub fn vision_read_by_sig(
        port: u8,
        size_id: u32,
        sig_id: u32,
        object_count: u32,
        object_arr: *mut vision_object_s_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Reads up to object_count object descriptors into object_arr."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21), or"]
    #[doc = "          fewer than object_count number of objects were found."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param object_count"]
    #[doc = "        The number of objects to read"]
    #[doc = " \\param size_id"]
    #[doc = "        The object to read from a list roughly ordered by object size"]
    #[doc = "        (0 is the largest item, 1 is the second largest, etc.)"]
    #[doc = " \\param color_code"]
    #[doc = "        The vision_color_code_t for which objects will be returned"]
    #[doc = " \\param[out] object_arr"]
    #[doc = "             A pointer to copy the objects into"]
    #[doc = ""]
    #[doc = " \\return The number of object signatures copied. This number will be less than"]
    #[doc = " object_count if there are fewer objects detected by the vision sensor."]
    #[doc = " Returns PROS_ERR if the port was invalid, an error occurred, or fewer objects"]
    #[doc = " than size_id were found. All objects in object_arr that were not found are"]
    #[doc = " given VISION_OBJECT_ERR_SIG as their signature."]
    pub fn vision_read_by_code(
        port: u8,
        size_id: u32,
        color_code: vision_color_code_t,
        object_count: u32,
        object_arr: *mut vision_object_s_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the object detection signature with the given id number."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param signature_id"]
    #[doc = "        The signature id to read"]
    #[doc = ""]
    #[doc = " \\return A vision_signature_s_t containing information about the signature."]
    pub fn vision_get_signature(port: u8, signature_id: u8) -> vision_signature_s_t;
}
extern "C" {
    #[doc = " Stores the supplied object detection signature onto the vision sensor."]
    #[doc = ""]
    #[doc = " NOTE: This saves the signature in volatile memory, and the signature will be"]
    #[doc = " lost as soon as the sensor is powered down."]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param signature_id"]
    #[doc = "        The signature id to store into"]
    #[doc = " \\param[in] signature_ptr"]
    #[doc = "            A pointer to the signature to save"]
    #[doc = ""]
    #[doc = " \\return 1 if no errors occured, PROS_ERR otherwise"]
    pub fn vision_set_signature(
        port: u8,
        signature_id: u8,
        signature_ptr: *mut vision_signature_s_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Enables/disables auto white-balancing on the Vision Sensor."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = " EINVAL - enable was not 0 or 1"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = " \t\t    The V5 port number from 1-21"]
    #[doc = " \\param enabled"]
    #[doc = " \t\t    Pass 0 to disable, 1 to enable"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn vision_set_auto_white_balance(port: u8, enable: u8) -> i32;
}
extern "C" {
    #[doc = " Sets the exposure parameter of the Vision Sensor. See"]
    #[doc = " https://pros.cs.purdue.edu/v5/tutorials/topical/vision.html#exposure-setting"]
    #[doc = " for more detials."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param percent"]
    #[doc = "        The new exposure setting from [0,150]"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn vision_set_exposure(port: u8, exposure: u8) -> i32;
}
extern "C" {
    #[doc = " Sets the vision sensor LED color, overriding the automatic behavior."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param rgb"]
    #[doc = "        An RGB code to set the LED to"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn vision_set_led(port: u8, rgb: i32) -> i32;
}
extern "C" {
    #[doc = " Sets the white balance parameter of the Vision Sensor."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = " \t\t    The V5 port number from 1-21"]
    #[doc = " \\param rgb"]
    #[doc = "        The new RGB white balance setting of the sensor"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn vision_set_white_balance(port: u8, rgb: i32) -> i32;
}
extern "C" {
    #[doc = " Sets the (0,0) coordinate for the Field of View."]
    #[doc = ""]
    #[doc = " This will affect the coordinates returned for each request for a"]
    #[doc = " vision_object_s_t from the sensor, so it is recommended that this function"]
    #[doc = " only be used to configure the sensor at the beginning of its use."]
    #[doc = ""]
    #[doc = " This function uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given value is not within the range of V5 ports (1-21)."]
    #[doc = " ENODEV - The port cannot be configured as a vision sensor"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = " \t\t    The V5 port number from 1-21"]
    #[doc = " \\param zero_point"]
    #[doc = "        One of vision_zero_e_t to set the (0,0) coordinate for the FOV"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn vision_set_zero_point(port: u8, zero_point: vision_zero_e_t) -> i32;
}
extern "C" {
    #[doc = " Sets the Wi-Fi mode of the Vision sensor"]
    #[doc = ""]
    #[doc = " This functions uses the following values of errno when an error state is"]
    #[doc = " reached:"]
    #[doc = " ENXIO - The given port is not within the range of V5 ports (1-21)"]
    #[doc = " EACCESS - Anothe resources is currently trying to access the port"]
    #[doc = ""]
    #[doc = " \\param port"]
    #[doc = "        The V5 port number from 1-21"]
    #[doc = " \\param enable"]
    #[doc = "        Disable Wi-Fi on the Vision sensor if 0, enable otherwise (e.g. 1)"]
    #[doc = ""]
    #[doc = " \\return 1 if the operation was successful or PROS_ERR if the operation"]
    #[doc = " failed, setting errno."]
    pub fn vision_set_wifi_mode(port: u8, enable: u8) -> i32;
}
